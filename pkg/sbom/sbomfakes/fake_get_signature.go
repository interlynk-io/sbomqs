// Code generated by counterfeiter. DO NOT EDIT.
package sbomfakes

import (
	"sync"

	"github.com/interlynk-io/sbomqs/v2/pkg/sbom"
)

type FakeGetSignature struct {
	GetAlgorithmStub        func() string
	getAlgorithmMutex       sync.RWMutex
	getAlgorithmArgsForCall []struct {
	}
	getAlgorithmReturns struct {
		result1 string
	}
	getAlgorithmReturnsOnCall map[int]struct {
		result1 string
	}
	GetCertificatePathStub        func() []string
	getCertificatePathMutex       sync.RWMutex
	getCertificatePathArgsForCall []struct {
	}
	getCertificatePathReturns struct {
		result1 []string
	}
	getCertificatePathReturnsOnCall map[int]struct {
		result1 []string
	}
	GetExcludesStub        func() []string
	getExcludesMutex       sync.RWMutex
	getExcludesArgsForCall []struct {
	}
	getExcludesReturns struct {
		result1 []string
	}
	getExcludesReturnsOnCall map[int]struct {
		result1 []string
	}
	GetKeyIDStub        func() string
	getKeyIDMutex       sync.RWMutex
	getKeyIDArgsForCall []struct {
	}
	getKeyIDReturns struct {
		result1 string
	}
	getKeyIDReturnsOnCall map[int]struct {
		result1 string
	}
	GetPublicKeyStub        func() string
	getPublicKeyMutex       sync.RWMutex
	getPublicKeyArgsForCall []struct {
	}
	getPublicKeyReturns struct {
		result1 string
	}
	getPublicKeyReturnsOnCall map[int]struct {
		result1 string
	}
	GetSigValueStub        func() string
	getSigValueMutex       sync.RWMutex
	getSigValueArgsForCall []struct {
	}
	getSigValueReturns struct {
		result1 string
	}
	getSigValueReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGetSignature) GetAlgorithm() string {
	fake.getAlgorithmMutex.Lock()
	ret, specificReturn := fake.getAlgorithmReturnsOnCall[len(fake.getAlgorithmArgsForCall)]
	fake.getAlgorithmArgsForCall = append(fake.getAlgorithmArgsForCall, struct {
	}{})
	stub := fake.GetAlgorithmStub
	fakeReturns := fake.getAlgorithmReturns
	fake.recordInvocation("GetAlgorithm", []interface{}{})
	fake.getAlgorithmMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGetSignature) GetAlgorithmCallCount() int {
	fake.getAlgorithmMutex.RLock()
	defer fake.getAlgorithmMutex.RUnlock()
	return len(fake.getAlgorithmArgsForCall)
}

func (fake *FakeGetSignature) GetAlgorithmCalls(stub func() string) {
	fake.getAlgorithmMutex.Lock()
	defer fake.getAlgorithmMutex.Unlock()
	fake.GetAlgorithmStub = stub
}

func (fake *FakeGetSignature) GetAlgorithmReturns(result1 string) {
	fake.getAlgorithmMutex.Lock()
	defer fake.getAlgorithmMutex.Unlock()
	fake.GetAlgorithmStub = nil
	fake.getAlgorithmReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) GetAlgorithmReturnsOnCall(i int, result1 string) {
	fake.getAlgorithmMutex.Lock()
	defer fake.getAlgorithmMutex.Unlock()
	fake.GetAlgorithmStub = nil
	if fake.getAlgorithmReturnsOnCall == nil {
		fake.getAlgorithmReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getAlgorithmReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) GetCertificatePath() []string {
	fake.getCertificatePathMutex.Lock()
	ret, specificReturn := fake.getCertificatePathReturnsOnCall[len(fake.getCertificatePathArgsForCall)]
	fake.getCertificatePathArgsForCall = append(fake.getCertificatePathArgsForCall, struct {
	}{})
	stub := fake.GetCertificatePathStub
	fakeReturns := fake.getCertificatePathReturns
	fake.recordInvocation("GetCertificatePath", []interface{}{})
	fake.getCertificatePathMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGetSignature) GetCertificatePathCallCount() int {
	fake.getCertificatePathMutex.RLock()
	defer fake.getCertificatePathMutex.RUnlock()
	return len(fake.getCertificatePathArgsForCall)
}

func (fake *FakeGetSignature) GetCertificatePathCalls(stub func() []string) {
	fake.getCertificatePathMutex.Lock()
	defer fake.getCertificatePathMutex.Unlock()
	fake.GetCertificatePathStub = stub
}

func (fake *FakeGetSignature) GetCertificatePathReturns(result1 []string) {
	fake.getCertificatePathMutex.Lock()
	defer fake.getCertificatePathMutex.Unlock()
	fake.GetCertificatePathStub = nil
	fake.getCertificatePathReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeGetSignature) GetCertificatePathReturnsOnCall(i int, result1 []string) {
	fake.getCertificatePathMutex.Lock()
	defer fake.getCertificatePathMutex.Unlock()
	fake.GetCertificatePathStub = nil
	if fake.getCertificatePathReturnsOnCall == nil {
		fake.getCertificatePathReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getCertificatePathReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeGetSignature) GetExcludes() []string {
	fake.getExcludesMutex.Lock()
	ret, specificReturn := fake.getExcludesReturnsOnCall[len(fake.getExcludesArgsForCall)]
	fake.getExcludesArgsForCall = append(fake.getExcludesArgsForCall, struct {
	}{})
	stub := fake.GetExcludesStub
	fakeReturns := fake.getExcludesReturns
	fake.recordInvocation("GetExcludes", []interface{}{})
	fake.getExcludesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGetSignature) GetExcludesCallCount() int {
	fake.getExcludesMutex.RLock()
	defer fake.getExcludesMutex.RUnlock()
	return len(fake.getExcludesArgsForCall)
}

func (fake *FakeGetSignature) GetExcludesCalls(stub func() []string) {
	fake.getExcludesMutex.Lock()
	defer fake.getExcludesMutex.Unlock()
	fake.GetExcludesStub = stub
}

func (fake *FakeGetSignature) GetExcludesReturns(result1 []string) {
	fake.getExcludesMutex.Lock()
	defer fake.getExcludesMutex.Unlock()
	fake.GetExcludesStub = nil
	fake.getExcludesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeGetSignature) GetExcludesReturnsOnCall(i int, result1 []string) {
	fake.getExcludesMutex.Lock()
	defer fake.getExcludesMutex.Unlock()
	fake.GetExcludesStub = nil
	if fake.getExcludesReturnsOnCall == nil {
		fake.getExcludesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getExcludesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeGetSignature) GetKeyID() string {
	fake.getKeyIDMutex.Lock()
	ret, specificReturn := fake.getKeyIDReturnsOnCall[len(fake.getKeyIDArgsForCall)]
	fake.getKeyIDArgsForCall = append(fake.getKeyIDArgsForCall, struct {
	}{})
	stub := fake.GetKeyIDStub
	fakeReturns := fake.getKeyIDReturns
	fake.recordInvocation("GetKeyID", []interface{}{})
	fake.getKeyIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGetSignature) GetKeyIDCallCount() int {
	fake.getKeyIDMutex.RLock()
	defer fake.getKeyIDMutex.RUnlock()
	return len(fake.getKeyIDArgsForCall)
}

func (fake *FakeGetSignature) GetKeyIDCalls(stub func() string) {
	fake.getKeyIDMutex.Lock()
	defer fake.getKeyIDMutex.Unlock()
	fake.GetKeyIDStub = stub
}

func (fake *FakeGetSignature) GetKeyIDReturns(result1 string) {
	fake.getKeyIDMutex.Lock()
	defer fake.getKeyIDMutex.Unlock()
	fake.GetKeyIDStub = nil
	fake.getKeyIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) GetKeyIDReturnsOnCall(i int, result1 string) {
	fake.getKeyIDMutex.Lock()
	defer fake.getKeyIDMutex.Unlock()
	fake.GetKeyIDStub = nil
	if fake.getKeyIDReturnsOnCall == nil {
		fake.getKeyIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getKeyIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) GetPublicKey() string {
	fake.getPublicKeyMutex.Lock()
	ret, specificReturn := fake.getPublicKeyReturnsOnCall[len(fake.getPublicKeyArgsForCall)]
	fake.getPublicKeyArgsForCall = append(fake.getPublicKeyArgsForCall, struct {
	}{})
	stub := fake.GetPublicKeyStub
	fakeReturns := fake.getPublicKeyReturns
	fake.recordInvocation("GetPublicKey", []interface{}{})
	fake.getPublicKeyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGetSignature) GetPublicKeyCallCount() int {
	fake.getPublicKeyMutex.RLock()
	defer fake.getPublicKeyMutex.RUnlock()
	return len(fake.getPublicKeyArgsForCall)
}

func (fake *FakeGetSignature) GetPublicKeyCalls(stub func() string) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = stub
}

func (fake *FakeGetSignature) GetPublicKeyReturns(result1 string) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = nil
	fake.getPublicKeyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) GetPublicKeyReturnsOnCall(i int, result1 string) {
	fake.getPublicKeyMutex.Lock()
	defer fake.getPublicKeyMutex.Unlock()
	fake.GetPublicKeyStub = nil
	if fake.getPublicKeyReturnsOnCall == nil {
		fake.getPublicKeyReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPublicKeyReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) GetSigValue() string {
	fake.getSigValueMutex.Lock()
	ret, specificReturn := fake.getSigValueReturnsOnCall[len(fake.getSigValueArgsForCall)]
	fake.getSigValueArgsForCall = append(fake.getSigValueArgsForCall, struct {
	}{})
	stub := fake.GetSigValueStub
	fakeReturns := fake.getSigValueReturns
	fake.recordInvocation("GetSigValue", []interface{}{})
	fake.getSigValueMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGetSignature) GetSigValueCallCount() int {
	fake.getSigValueMutex.RLock()
	defer fake.getSigValueMutex.RUnlock()
	return len(fake.getSigValueArgsForCall)
}

func (fake *FakeGetSignature) GetSigValueCalls(stub func() string) {
	fake.getSigValueMutex.Lock()
	defer fake.getSigValueMutex.Unlock()
	fake.GetSigValueStub = stub
}

func (fake *FakeGetSignature) GetSigValueReturns(result1 string) {
	fake.getSigValueMutex.Lock()
	defer fake.getSigValueMutex.Unlock()
	fake.GetSigValueStub = nil
	fake.getSigValueReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) GetSigValueReturnsOnCall(i int, result1 string) {
	fake.getSigValueMutex.Lock()
	defer fake.getSigValueMutex.Unlock()
	fake.GetSigValueStub = nil
	if fake.getSigValueReturnsOnCall == nil {
		fake.getSigValueReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getSigValueReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeGetSignature) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGetSignature) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ sbom.GetSignature = new(FakeGetSignature)
