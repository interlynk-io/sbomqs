// Code generated by counterfeiter. DO NOT EDIT.
package sbomfakes

import (
	"sync"

	"github.com/interlynk-io/sbomqs/pkg/sbom"
)

type FakeLicense struct {
	DeprecatedStub        func() bool
	deprecatedMutex       sync.RWMutex
	deprecatedArgsForCall []struct {
	}
	deprecatedReturns struct {
		result1 bool
	}
	deprecatedReturnsOnCall map[int]struct {
		result1 bool
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ShortStub        func() string
	shortMutex       sync.RWMutex
	shortArgsForCall []struct {
	}
	shortReturns struct {
		result1 string
	}
	shortReturnsOnCall map[int]struct {
		result1 string
	}
	ValidSpdxLicenseStub        func() bool
	validSpdxLicenseMutex       sync.RWMutex
	validSpdxLicenseArgsForCall []struct {
	}
	validSpdxLicenseReturns struct {
		result1 bool
	}
	validSpdxLicenseReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLicense) Deprecated() bool {
	fake.deprecatedMutex.Lock()
	ret, specificReturn := fake.deprecatedReturnsOnCall[len(fake.deprecatedArgsForCall)]
	fake.deprecatedArgsForCall = append(fake.deprecatedArgsForCall, struct {
	}{})
	stub := fake.DeprecatedStub
	fakeReturns := fake.deprecatedReturns
	fake.recordInvocation("Deprecated", []interface{}{})
	fake.deprecatedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLicense) DeprecatedCallCount() int {
	fake.deprecatedMutex.RLock()
	defer fake.deprecatedMutex.RUnlock()
	return len(fake.deprecatedArgsForCall)
}

func (fake *FakeLicense) DeprecatedCalls(stub func() bool) {
	fake.deprecatedMutex.Lock()
	defer fake.deprecatedMutex.Unlock()
	fake.DeprecatedStub = stub
}

func (fake *FakeLicense) DeprecatedReturns(result1 bool) {
	fake.deprecatedMutex.Lock()
	defer fake.deprecatedMutex.Unlock()
	fake.DeprecatedStub = nil
	fake.deprecatedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLicense) DeprecatedReturnsOnCall(i int, result1 bool) {
	fake.deprecatedMutex.Lock()
	defer fake.deprecatedMutex.Unlock()
	fake.DeprecatedStub = nil
	if fake.deprecatedReturnsOnCall == nil {
		fake.deprecatedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.deprecatedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLicense) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLicense) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeLicense) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeLicense) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeLicense) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeLicense) Short() string {
	fake.shortMutex.Lock()
	ret, specificReturn := fake.shortReturnsOnCall[len(fake.shortArgsForCall)]
	fake.shortArgsForCall = append(fake.shortArgsForCall, struct {
	}{})
	stub := fake.ShortStub
	fakeReturns := fake.shortReturns
	fake.recordInvocation("Short", []interface{}{})
	fake.shortMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLicense) ShortCallCount() int {
	fake.shortMutex.RLock()
	defer fake.shortMutex.RUnlock()
	return len(fake.shortArgsForCall)
}

func (fake *FakeLicense) ShortCalls(stub func() string) {
	fake.shortMutex.Lock()
	defer fake.shortMutex.Unlock()
	fake.ShortStub = stub
}

func (fake *FakeLicense) ShortReturns(result1 string) {
	fake.shortMutex.Lock()
	defer fake.shortMutex.Unlock()
	fake.ShortStub = nil
	fake.shortReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeLicense) ShortReturnsOnCall(i int, result1 string) {
	fake.shortMutex.Lock()
	defer fake.shortMutex.Unlock()
	fake.ShortStub = nil
	if fake.shortReturnsOnCall == nil {
		fake.shortReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.shortReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeLicense) ValidSpdxLicense() bool {
	fake.validSpdxLicenseMutex.Lock()
	ret, specificReturn := fake.validSpdxLicenseReturnsOnCall[len(fake.validSpdxLicenseArgsForCall)]
	fake.validSpdxLicenseArgsForCall = append(fake.validSpdxLicenseArgsForCall, struct {
	}{})
	stub := fake.ValidSpdxLicenseStub
	fakeReturns := fake.validSpdxLicenseReturns
	fake.recordInvocation("ValidSpdxLicense", []interface{}{})
	fake.validSpdxLicenseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLicense) ValidSpdxLicenseCallCount() int {
	fake.validSpdxLicenseMutex.RLock()
	defer fake.validSpdxLicenseMutex.RUnlock()
	return len(fake.validSpdxLicenseArgsForCall)
}

func (fake *FakeLicense) ValidSpdxLicenseCalls(stub func() bool) {
	fake.validSpdxLicenseMutex.Lock()
	defer fake.validSpdxLicenseMutex.Unlock()
	fake.ValidSpdxLicenseStub = stub
}

func (fake *FakeLicense) ValidSpdxLicenseReturns(result1 bool) {
	fake.validSpdxLicenseMutex.Lock()
	defer fake.validSpdxLicenseMutex.Unlock()
	fake.ValidSpdxLicenseStub = nil
	fake.validSpdxLicenseReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLicense) ValidSpdxLicenseReturnsOnCall(i int, result1 bool) {
	fake.validSpdxLicenseMutex.Lock()
	defer fake.validSpdxLicenseMutex.Unlock()
	fake.ValidSpdxLicenseStub = nil
	if fake.validSpdxLicenseReturnsOnCall == nil {
		fake.validSpdxLicenseReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.validSpdxLicenseReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLicense) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deprecatedMutex.RLock()
	defer fake.deprecatedMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.shortMutex.RLock()
	defer fake.shortMutex.RUnlock()
	fake.validSpdxLicenseMutex.RLock()
	defer fake.validSpdxLicenseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLicense) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ sbom.License = new(FakeLicense)
