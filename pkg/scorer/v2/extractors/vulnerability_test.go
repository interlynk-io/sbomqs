// Copyright 2025 Interlynk.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package extractors

import (
	"testing"

	"github.com/interlynk-io/sbomqs/pkg/cpe"
	"github.com/interlynk-io/sbomqs/pkg/purl"
	"github.com/interlynk-io/sbomqs/pkg/sbom"
	"github.com/stretchr/testify/assert"
)

type vulnMiniComp struct {
	id, name, version string
	purls             []string
	cpes              []string
}

type vulnCdx14MiniComp struct {
	id, name, version string
	purl              string
	cpe               string
}

func makeCDX14DocForVuln(comps []vulnCdx14MiniComp) sbom.Document {
	s := sbom.NewSpec()
	s.Version = "1.4"
	s.SpecType = "cyclonedx"
	s.Format = "json"
	s.URI = "urn:uuid:11111111-2222-3333-4444-555555555555"

	var cs []sbom.GetComponent
	for _, m := range comps {
		c := sbom.NewComponent()
		c.ID = m.id
		c.Name = m.name
		c.Version = m.version

		c.Cpes = append(c.Cpes, cpe.CPE(m.cpe))
		c.Purls = append(c.Purls, purl.PURL(m.purl))

		cs = append(cs, c)
	}

	return sbom.CdxDoc{CdxSpec: s, Comps: cs}
}

func makeSPDXDocForVuln(comps []vulnMiniComp) sbom.Document {
	s := sbom.NewSpec()
	s.Version = "SPDX-2.3"
	s.SpecType = "spdx"
	s.Format = "json"
	s.Spdxid = "DOCUMENT"
	s.Namespace = "https://example.com/ns"
	s.CreationTimestamp = "2025-01-01T00:00:00Z"

	var cs []sbom.GetComponent
	for _, m := range comps {
		c := sbom.NewComponent()
		c.ID, c.Name, c.Version = m.id, m.name, m.version
		for _, p := range m.purls {
			c.Purls = append(c.Purls, purl.PURL(p))
		}
		for _, cp := range m.cpes {
			c.Cpes = append(c.Cpes, cpe.CPE(cp))
		}
		cs = append(cs, c)
	}

	return sbom.SpdxDoc{SpdxSpec: s, Comps: cs}
}

func Test_CompWithPURL(t *testing.T) {
	t.Run("SpdxWithNoComponents", func(t *testing.T) {
		doc := makeSPDXDocForVuln(nil)

		got := CompWithPURL(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.True(t, got.Ignore)
		assert.Equal(t, "N/A (no components)", got.Desc)
	})

	t.Run("SpdxWithALLValidPURLs", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{id: "SPDXRef-A", name: "a", version: "1.0.0", purls: []string{"pkg:npm/lodash@4.17.21"}},
			{id: "SPDXRef-B", name: "b", version: "2.0.0", purls: []string{"pkg:maven/org.apache.commons/commons-lang3@3.12.0"}},
		})
		got := CompWithPURL(doc)

		assert.InDelta(t, 10.0, got.Score, 1e-9)
		assert.Equal(t, "2/2 have PURLs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("SpdxWithPartialValidPURLs", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{id: "SPDXRef-A", name: "a", version: "1", purls: []string{"pkg:golang/github.com/pkg/errors@0.9.1"}},
			{id: "SPDXRef-B", name: "b", version: "2", purls: []string{"not-a-purl"}},
			{id: "SPDXRef-C", name: "c", version: "3", purls: []string{}},
		})
		got := CompWithPURL(doc)
		// 1/3 = 3.333â€¦
		assert.InDelta(t, 10.0*(1.0/3.0), got.Score, 1e-9)
		assert.Equal(t, "1/3 have PURLs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("SpdxWithNoValidPURLs", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{id: "SPDXRef-A", name: "a", version: "1", purls: []string{"pkg:", "pkg:/", "notpkg:npm/foo"}},
			{id: "SPDXRef-B", name: "b", version: "2"},
		})
		got := CompWithPURL(doc)
		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "0/2 have PURLs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("SpdxPURLWithQualifiersAndSubpath", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{
				id: "SPDXRef-A", name: "a", version: "1",
				purls: []string{"pkg:maven/org.apache.commons/commons-lang3@3.12.0?classifier=sources#src/main"},
			},
		})
		got := CompWithPURL(doc)

		assert.InDelta(t, 10.0, got.Score, 1e-9)
		assert.Equal(t, "1/1 have PURLs", got.Desc)
	})

	t.Run("SpdxWithMultiplePURLsOneValid", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{
				id: "SPDXRef-A", name: "a", version: "1",
				purls: []string{"not-a-purl", "pkg:npm/lodash@4.17.21"},
			},
			{
				id: "SPDXRef-B", name: "b", version: "2",
				purls: []string{"pkg:", "pkg:/"},
			},
		})
		got := CompWithPURL(doc)

		assert.InDelta(t, 10.0*(1.0/2.0), got.Score, 1e-9)
		assert.Equal(t, "1/2 have PURLs", got.Desc)
	})

	// CDX:1.4
	t.Run("CDXWithALLValidPURLs", func(t *testing.T) {
		doc := makeCDX14DocForVuln([]vulnCdx14MiniComp{
			{id: "a", name: "a", version: "1.0.0", purl: "pkg:npm/lodash@4.17.21"},
			{id: "b", name: "b", version: "2.0.0", purl: "pkg:maven/org.apache.commons/commons-lang3@3.12.0"},
		})
		got := CompWithPURL(doc)

		assert.InDelta(t, 10.0, got.Score, 1e-9)
		assert.Equal(t, "2/2 have PURLs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("CDXWithPartialValidPURLs", func(t *testing.T) {
		doc := makeCDX14DocForVuln([]vulnCdx14MiniComp{
			{id: "a", name: "a", version: "1", purl: "pkg:golang/github.com/pkg/errors@0.9.1"},
			{id: "b", name: "b", version: "2", purl: "not-a-purl"},
			{id: "c", name: "c", version: "3", purl: ""},
		})

		got := CompWithPURL(doc)

		assert.InDelta(t, 10.0*(1.0/3.0), got.Score, 1e-9)
		assert.Equal(t, "1/3 have PURLs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("CDXWithNoValidPURLs", func(t *testing.T) {
		doc := makeCDX14DocForVuln([]vulnCdx14MiniComp{
			{id: "a", name: "a", version: "1", purl: "notpkg:npm/foo"},
			{id: "b", name: "b", version: "2"},
		})

		got := CompWithPURL(doc)

		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "0/2 have PURLs", got.Desc)
		assert.False(t, got.Ignore)
	})
}

func Test_CompWithCPE(t *testing.T) {
	t.Run("SpdxWithNoComponents", func(t *testing.T) {
		doc := makeSPDXDocForVuln(nil)

		got := CompWithCPE(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.True(t, got.Ignore)
		assert.Equal(t, "N/A (no components)", got.Desc)
	})

	t.Run("SpdxWithALLValidCPE23", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{
				id: "SPDXRef-A", name: "a", version: "1",
				cpes: []string{"cpe:2.3:a:nginx:nginx:1.24.0:*:*:*:*:*:*:*"},
			},
			{
				id: "SPDXRef-B", name: "b", version: "2",
				cpes: []string{"cpe:2.3:a:openssl:openssl:3.0.13:*:*:*:*:*:*:*"},
			},
		})

		got := CompWithCPE(doc)

		assert.InDelta(t, 10.0, got.Score, 1e-9)
		assert.Equal(t, "2/2 have CPEs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("SpdxWithPartialValidCPE23", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{id: "SPDXRef-A", name: "a", version: "1", cpes: []string{"cpe:2.3:a:vendor:prod:1.0:*:*:*:*:*:*:*"}}, // valid
			{id: "SPDXRef-B", name: "b", version: "2", cpes: []string{"cpe:/a:vendor:prod:1.0"}},                  // old but valid
			{id: "SPDXRef-C", name: "c", version: "3", cpes: []string{"cpe:2.3:a:just:not:enough:fields"}},        // invalid
		})

		got := CompWithCPE(doc)

		assert.InDelta(t, 10.0*(2.0/3.0), got.Score, 1e-9)
		assert.Equal(t, "2/3 have CPEs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("SpdxWithNoneValidCPE23", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{id: "SPDXRef-A", name: "a", version: "1", cpes: []string{"cpe:2.3"}},
			{id: "SPDXRef-B", name: "b", version: "2", cpes: []string{"not-a-cpe"}},
			{id: "SPDXRef-C", name: "c", version: "3", cpes: []string{"cpe:2.3:a:just:not:enough:fields"}}, // old/invalid shape

		})

		got := CompWithCPE(doc)

		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "0/3 have CPEs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("SpdxWithMultipleCPEsOneValid", func(t *testing.T) {
		doc := makeSPDXDocForVuln([]vulnMiniComp{
			{
				id: "SPDXRef-A", name: "a", version: "1",
				cpes: []string{"cpe:2.3:a:vendor:prod:1.0:*:*:*:*:*:*:*", "cpe:/a:bad:shape"},
			},
			{
				id: "SPDXRef-B", name: "b", version: "2",
				cpes: []string{"not-a-cpe", "cpe:2.3:a:just:not:enough:fields"},
			},
		})
		got := CompWithCPE(doc)
		assert.InDelta(t, 10.0*(1.0/2.0), got.Score, 1e-9)
		assert.Equal(t, "1/2 have CPEs", got.Desc)
	})

	// CDX:1.4
	t.Run("CDXWithALLValidCPEs", func(t *testing.T) {
		doc := makeCDX14DocForVuln([]vulnCdx14MiniComp{
			{id: "a", name: "a", version: "1.0.0", cpe: "cpe:2.3:a:nginx:nginx:1.24.0:*:*:*:*:*:*:*"},
			{id: "b", name: "b", version: "2.0.0", cpe: "cpe:2.3:a:openssl:openssl:3.0.13:*:*:*:*:*:*:*"},
		})

		got := CompWithCPE(doc)

		assert.InDelta(t, 10.0, got.Score, 1e-9)
		assert.Equal(t, "2/2 have CPEs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("CDXWithPartialValidPURLs", func(t *testing.T) {
		doc := makeCDX14DocForVuln([]vulnCdx14MiniComp{
			{id: "a", name: "a", version: "1.0.0", cpe: "cpe:2.3:a:vendor:prod:1.0:*:*:*:*:*:*:*"},
			{id: "b", name: "b", version: "2.0.0", cpe: "cpe:/a:vendor:prod:1.0"},
			{id: "c", name: "c", version: "3.0.0", cpe: "cpe:2.3:a:just:not:enough:fields"},
		})

		got := CompWithCPE(doc)

		assert.InDelta(t, 10.0*(2.0/3.0), got.Score, 1e-9)
		assert.Equal(t, "2/3 have CPEs", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("CDXWithNoValidPURLs", func(t *testing.T) {
		doc := makeCDX14DocForVuln([]vulnCdx14MiniComp{
			{id: "a", name: "a", version: "1.0.0", cpe: "cpe:2.3"},
			{id: "b", name: "b", version: "2.0.0", cpe: "not-a-cpe"},
			{id: "c", name: "c", version: "3.0.0", cpe: "cpe:2.3:a:just:not:enough:fields"},
		})

		got := CompWithCPE(doc)

		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "0/3 have CPEs", got.Desc)
		assert.False(t, got.Ignore)
	})
}
