level=warning msg="[runner/nolint_filter] Found unknown linters in //nolint directives: stylecheck"
pkg/compliance/bsi.go:376: 376-399 lines are duplicate of `pkg/compliance/ntia.go:313-340` (dupl)
	if doc.Spec().GetSpecType() == string(sbom.SBOMSpecSPDX) {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(bsiGetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}

		dependencies = doc.GetRelationships(common.GetID(component.GetSpdxID()))
		if dependencies == nil {
			if bsiPrimaryDependencies[common.GetID(component.GetSpdxID())] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")
		}
		allDepByName = common.GetDependenciesByName(dependencies, bsiCompIDWithName)
		if bsiPrimaryDependencies[common.GetID(component.GetSpdxID())] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}
		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")

	} else if doc.Spec().GetSpecType() == string(sbom.SBOMSpecCDX) {
pkg/compliance/bsi.go:399: 399-421 lines are duplicate of `pkg/compliance/ntia.go:340-363` (dupl)
	} else if doc.Spec().GetSpecType() == string(sbom.SBOMSpecCDX) {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(bsiGetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}
		id := component.GetID()
		dependencies = doc.GetRelationships(id)
		if len(dependencies) == 0 {
			if bsiPrimaryDependencies[id] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")
		}
		allDepByName = common.GetDependenciesByName(dependencies, bsiCompIDWithName)
		if bsiPrimaryDependencies[id] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}
		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
	}
pkg/compliance/bsi_test.go:45: 45-79 lines are duplicate of `pkg/compliance/bsi_test.go:174-208` (dupl)
func TestBSIWithSbomSpecFields(t *testing.T) {
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desired
	}{
		{
			name:   "sbomWithCdxSpec",
			actual: bsiSpec(cdxDocWithSpec()),
			expected: desired{
				score:  10.0,
				result: "cyclonedx",
				key:    SBOM_SPEC,
				id:     "doc",
			},
		},
		{
			name:   "sbomWithSpdxSpec",
			actual: bsiSpec(spdxDocWithSpec()),
			expected: desired{
				score:  10.0,
				result: "spdx",
				key:    SBOM_SPEC,
				id:     "doc",
			},
		},
	}

	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/bsi_test.go:174: 174-208 lines are duplicate of `pkg/compliance/bsi_test.go:45-79` (dupl)
func TestBSIWithBuildPhaseField(t *testing.T) {
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desired
	}{
		{
			name:   "spdxSbomWithCustomLifecycle",
			actual: bsiBuildPhase(spdxDocWithLifecycles()),
			expected: desired{
				score:  0.0,
				result: "",
				key:    SBOM_BUILD,
				id:     "doc",
			},
		},
		{
			name:   "cdxSbomWithBuildLifecycle",
			actual: bsiBuildPhase(cdxDocWithLifecycles()),
			expected: desired{
				score:  10.0,
				result: "build",
				key:    SBOM_BUILD,
				id:     "doc",
			},
		},
	}

	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/ntia.go:313: 313-340 lines are duplicate of `pkg/compliance/bsi.go:376-399` (dupl)
	if doc.Spec().GetSpecType() == "spdx" {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(GetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}

		dependencies = doc.GetRelationships(common.GetID(component.GetSpdxID()))
		if dependencies == nil {

			if primaryDependencies[common.GetID(component.GetSpdxID())] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")

		}
		allDepByName = common.GetDependenciesByName(dependencies, compIDWithName)

		if primaryDependencies[common.GetID(component.GetSpdxID())] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}

		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")

	} else if doc.Spec().GetSpecType() == "cyclonedx" {
pkg/compliance/ntia.go:340: 340-363 lines are duplicate of `pkg/compliance/bsi.go:399-421` (dupl)
	} else if doc.Spec().GetSpecType() == "cyclonedx" {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(GetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}
		id := component.GetID()
		dependencies = doc.GetRelationships(id)
		if len(dependencies) == 0 {
			if primaryDependencies[id] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")
		}
		allDepByName = common.GetDependenciesByName(dependencies, compIDWithName)
		if primaryDependencies[id] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}
		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")

	}
pkg/compliance/ntia_report.go:101: 101-152 lines are duplicate of `pkg/compliance/oct_report.go:120-171` (dupl)
func ntiaConstructSections(db *db.DB) []ntiaSection {
	var sections []ntiaSection
	allIDs := db.GetAllIDs()
	for _, id := range allIDs {
		records := db.GetRecordsByID(id)

		for _, r := range records {
			section := ntiaSectionDetails[r.CheckKey]
			newSection := ntiaSection{
				Title:     section.Title,
				ID:        section.ID,
				DataField: section.DataField,
				Required:  section.Required,
			}
			score := ntiaKeyIDScore(db, r.CheckKey, r.ID)
			newSection.Score = score.totalScore()
			if r.ID == "doc" {
				newSection.ElementID = "sbom"
			} else {
				newSection.ElementID = r.ID
			}

			newSection.ElementResult = r.CheckValue

			sections = append(sections, newSection)
		}
	}
	// Group sections by ElementID
	sectionsByElementID := make(map[string][]ntiaSection)
	for _, section := range sections {
		sectionsByElementID[section.ElementID] = append(sectionsByElementID[section.ElementID], section)
	}

	// Sort each group of sections by section.ID and ensure "SBOM Data Fields" comes first within its group if it exists
	var sortedSections []ntiaSection
	var sbomLevelSections []ntiaSection
	for elementID, group := range sectionsByElementID {
		sort.Slice(group, func(i, j int) bool {
			return group[i].ID < group[j].ID
		})
		if elementID == "SBOM Level" {
			sbomLevelSections = group
		} else {
			sortedSections = append(sortedSections, group...)
		}
	}

	// Place "SBOM Level" sections at the top
	sortedSections = append(sbomLevelSections, sortedSections...)

	return sortedSections
}
pkg/compliance/ntia_score.go:15: 15-144 lines are duplicate of `pkg/compliance/oct_score.go:15-144` (dupl)
package compliance

import "github.com/interlynk-io/sbomqs/v2/pkg/compliance/db"

type ntiaScoreResult struct {
	id              string
	requiredScore   float64
	optionalScore   float64
	requiredRecords int
	optionalRecords int
}

func newNtiaScoreResult(id string) *ntiaScoreResult {
	return &ntiaScoreResult{id: id}
}

func (r *ntiaScoreResult) totalScore() float64 {
	if r.requiredRecords == 0 && r.optionalRecords == 0 {
		return 0.0
	}

	if r.requiredRecords != 0 && r.optionalRecords != 0 {
		return (r.totalRequiredScore() + r.totalOptionalScore()) / 2
	}

	if r.requiredRecords == 0 && r.optionalRecords != 0 {
		return r.totalOptionalScore()
	}

	return r.totalRequiredScore()
}

func (r *ntiaScoreResult) totalRequiredScore() float64 {
	if r.requiredRecords == 0 {
		return 0.0
	}

	return r.requiredScore / float64(r.requiredRecords)
}

func (r *ntiaScoreResult) totalOptionalScore() float64 {
	if r.optionalRecords == 0 {
		return 0.0
	}

	return r.optionalScore / float64(r.optionalRecords)
}

func ntiaKeyIDScore(db *db.DB, key int, id string) *ntiaScoreResult {
	records := db.GetRecordsByKeyID(key, id)

	if len(records) == 0 {
		return newNtiaScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &ntiaScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}

func ntiaAggregateScore(db *db.DB) *ntiaScoreResult {
	var results []ntiaScoreResult
	var finalResult ntiaScoreResult

	ids := db.GetAllIDs()
	for _, id := range ids {
		results = append(results, *ntiaIDScore(db, id))
	}

	for _, r := range results {
		finalResult.requiredScore += r.requiredScore
		finalResult.optionalScore += r.optionalScore
		finalResult.requiredRecords += r.requiredRecords
		finalResult.optionalRecords += r.optionalRecords
	}

	return &finalResult
}

func ntiaIDScore(db *db.DB, id string) *ntiaScoreResult {
	records := db.GetRecordsByID(id)

	if len(records) == 0 {
		return newNtiaScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &ntiaScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}
pkg/compliance/ntia_test.go:89: 89-196 lines are duplicate of `pkg/compliance/ntia_test.go:254-358` (dupl)
func TestNtiaSpdxSbomPass(t *testing.T) {
	doc := createSpdxDummyDocumentNtia()
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desiredNtia
	}{
		{
			name:   "AutomationSpec",
			actual: ntiaAutomationSpec(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "spdx, json",
				key:    SBOM_MACHINE_FORMAT,
				id:     "Automation Support",
			},
		},
		{
			name:   "SbomCreator",
			actual: ntiaSbomCreator(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "syft",
				key:    SBOM_CREATOR,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomCreatedTimestamp",
			actual: ntiaSbomCreatedTimestamp(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "2023-05-04T09:33:40Z",
				key:    SBOM_TIMESTAMP,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomDependency",
			actual: ntiaSBOMDependency(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "doc has 1 dependencies",
				key:    SBOM_DEPENDENCY,
				id:     "SBOM Data Fields",
			},
		},

		{
			name:   "ComponentCreator",
			actual: ntiaComponentCreator(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "hello@interlynk.io",
				key:    COMP_CREATOR,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},

		{
			name:   "ComponentName",
			actual: ntiaComponentName(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "tool-golang",
				key:    COMP_NAME,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentVersion",
			actual: ntiaComponentVersion(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "v0.7.1",
				key:    COMP_VERSION,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentOtherUniqIDs",
			actual: ntiaComponentOtherUniqIDs(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "purl:(1/1)",
				key:    COMP_OTHER_UNIQ_IDS,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentDependencies",
			actual: ntiaComponentDependencies(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "gordf",
				key:    COMP_DEPTH,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
	}

	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/ntia_test.go:254: 254-358 lines are duplicate of `pkg/compliance/ntia_test.go:89-196` (dupl)
func TestNtiaCdxSbomPass(t *testing.T) {
	doc := createCdxDummyDocumentNtia()
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desiredNtia
	}{
		{
			name:   "AutomationSpec",
			actual: ntiaAutomationSpec(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "cyclonedx, xml",
				key:    SBOM_MACHINE_FORMAT,
				id:     "Automation Support",
			},
		},
		{
			name:   "SbomCreator",
			actual: ntiaSbomCreator(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "hello@interlynk.io",
				key:    SBOM_CREATOR,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomCreatedTimestamp",
			actual: ntiaSbomCreatedTimestamp(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "2023-05-04T09:33:40Z",
				key:    SBOM_TIMESTAMP,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomDependency",
			actual: ntiaSBOMDependency(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "doc has 1 dependencies",
				key:    SBOM_DEPENDENCY,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "ComponentCreator",
			actual: ntiaComponentCreator(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "hello@interlynk.io",
				key:    COMP_CREATOR,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentName",
			actual: ntiaComponentName(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "tool-golang",
				key:    COMP_NAME,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentVersion",
			actual: ntiaComponentVersion(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "v0.7.1",
				key:    COMP_VERSION,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentOtherUniqIDs",
			actual: ntiaComponentOtherUniqIDs(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "vivek",
				key:    COMP_OTHER_UNIQ_IDS,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentDependencies",
			actual: ntiaComponentDependencies(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "gordf",
				key:    COMP_DEPTH,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
	}
	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/oct_report.go:120: 120-171 lines are duplicate of `pkg/compliance/ntia_report.go:101-152` (dupl)
func octConstructSections(dtb *db.DB) []octSection {
	var sections []octSection
	allIDs := dtb.GetAllIDs()
	for _, id := range allIDs {
		records := dtb.GetRecordsByID(id)

		for _, r := range records {
			section := octSectionDetails[r.CheckKey]
			newSection := octSection{
				Title:     section.Title,
				ID:        section.ID,
				DataField: section.DataField,
				Required:  section.Required,
			}
			score := octKeyIDScore(dtb, r.CheckKey, r.ID)
			newSection.Score = score.totalScore()
			if r.ID == "SPDX Elements" {
				newSection.ElementID = "SPDX Elements"
			} else {
				newSection.ElementID = r.ID
			}

			newSection.ElementResult = r.CheckValue

			sections = append(sections, newSection)
		}
	}
	// Group sections by ElementID
	sectionsByElementID := make(map[string][]octSection)
	for _, section := range sections {
		sectionsByElementID[section.ElementID] = append(sectionsByElementID[section.ElementID], section)
	}

	// Sort each group of sections by section.ID and ensure "SPDX Elements" comes first within its group if it exists
	var sortedSections []octSection
	var sbomLevelSections []octSection
	for elementID, group := range sectionsByElementID {
		sort.Slice(group, func(i, j int) bool {
			return group[i].ID < group[j].ID
		})
		if elementID == "SPDX Elements" {
			sbomLevelSections = group
		} else {
			sortedSections = append(sortedSections, group...)
		}
	}

	// Place "SBOM Level" sections at the top
	sortedSections = append(sbomLevelSections, sortedSections...)

	return sortedSections
}
pkg/compliance/oct_score.go:15: 15-144 lines are duplicate of `pkg/compliance/ntia_score.go:15-144` (dupl)
package compliance

import "github.com/interlynk-io/sbomqs/v2/pkg/compliance/db"

type octScoreResult struct {
	id              string
	requiredScore   float64
	optionalScore   float64
	requiredRecords int
	optionalRecords int
}

func newOctScoreResult(id string) *octScoreResult {
	return &octScoreResult{id: id}
}

func (r *octScoreResult) totalScore() float64 {
	if r.requiredRecords == 0 && r.optionalRecords == 0 {
		return 0.0
	}

	if r.requiredRecords != 0 && r.optionalRecords != 0 {
		return (r.totalRequiredScore() + r.totalOptionalScore()) / 2
	}

	if r.requiredRecords == 0 && r.optionalRecords != 0 {
		return r.totalOptionalScore()
	}

	return r.totalRequiredScore()
}

func (r *octScoreResult) totalRequiredScore() float64 {
	if r.requiredRecords == 0 {
		return 0.0
	}

	return r.requiredScore / float64(r.requiredRecords)
}

func (r *octScoreResult) totalOptionalScore() float64 {
	if r.optionalRecords == 0 {
		return 0.0
	}

	return r.optionalScore / float64(r.optionalRecords)
}

func octKeyIDScore(dtb *db.DB, key int, id string) *octScoreResult {
	records := dtb.GetRecordsByKeyID(key, id)

	if len(records) == 0 {
		return newOctScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &octScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}

func octAggregateScore(dtb *db.DB) *octScoreResult {
	var results []octScoreResult
	var finalResult octScoreResult

	ids := dtb.GetAllIDs()
	for _, id := range ids {
		results = append(results, *octIDScore(dtb, id))
	}

	for _, r := range results {
		finalResult.requiredScore += r.requiredScore
		finalResult.optionalScore += r.optionalScore
		finalResult.requiredRecords += r.requiredRecords
		finalResult.optionalRecords += r.optionalRecords
	}

	return &finalResult
}

func octIDScore(dtb *db.DB, id string) *octScoreResult {
	records := dtb.GetRecordsByID(id)

	if len(records) == 0 {
		return newOctScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &octScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}
pkg/compliance/oct_test.go:27: 27-88 lines are duplicate of `pkg/compliance/oct_test.go:368-429` (dupl)
func createDummyDocument() sbom.Document {
	s := sbom.NewSpec()
	s.Version = "SPDX-2.3"
	s.Format = "json"
	s.SpecType = "spdx"
	s.Name = "nano"
	s.Namespace = "https://anchore.com/syft/dir/sbomqs-6ec18b03-96cb-4951-b299-929890c1cfc8"
	s.Organization = "interlynk"
	s.CreationTimestamp = "2023-05-04T09:33:40Z"
	s.Spdxid = "DOCUMENT"
	s.Comment = "this is a general sbom created using syft tool"
	lics := licenses.CreateCustomLicense("", "cc0-1.0")
	s.Licenses = append(s.Licenses, lics)

	var tools []sbom.GetTool
	tool := sbom.Tool{
		Name: "syft",
	}
	tools = append(tools, tool)

	pack := sbom.NewComponent()
	pack.Version = "v0.7.1"
	pack.Name = "core-js"
	pack.Spdxid = "SPDXRef-npm-core-js-3.6.5"
	pack.CopyRight = "Copyright 2001-2011 The Apache Software Foundation"
	pack.FileAnalyzed = true
	pack.ID = "Package-go-module-github.com-CycloneDX-cyclonedx-go-21b8492723f5584d"
	pack.PackageLicenseConcluded = "(LGPL-2.0-only OR LicenseRef-3)"
	pack.PackageLicenseDeclared = "(LGPL-2.0-only AND LicenseRef-3)"
	pack.DownloadLocation = "https://registry.npmjs.org/core-js/-/core-js-3.6.5.tgz"

	supplier := sbom.Supplier{
		Email: "vivekkumarsahu650@gmail.com",
	}
	pack.Supplier = supplier

	checksum := sbom.Checksum{
		Alg:     "SHA256",
		Content: "ee1300ac533cebc2d070ce3765685d5f7fca2a5a78ca15068323f68ed63d4abf",
	}

	var checksums []sbom.GetChecksum
	checksums = append(checksums, checksum)
	pack.Checksums = checksums

	extRef := sbom.ExternalReference{
		RefType: "purl",
	}
	var externalReferences []sbom.GetExternalReference
	externalReferences = append(externalReferences, extRef)
	pack.ExternalRefs = externalReferences

	var packages []sbom.GetComponent
	packages = append(packages, pack)

	doc := sbom.SpdxDoc{
		SpdxSpec:  s,
		Comps:     packages,
		SpdxTools: tools,
	}
	return doc
}
pkg/compliance/oct_test.go:368: 368-429 lines are duplicate of `pkg/compliance/oct_test.go:27-88` (dupl)
func createFailureDummyDocument() sbom.Document {
	s := sbom.NewSpec()
	s.Version = ""
	s.Format = "xml"
	s.SpecType = "cyclonedx"
	s.Name = ""
	s.Namespace = ""
	s.Organization = ""
	s.CreationTimestamp = "wrong-time-format"
	s.Spdxid = ""
	s.Comment = ""
	lics := licenses.CreateCustomLicense("", "")
	s.Licenses = append(s.Licenses, lics)

	var tools []sbom.GetTool
	tool := sbom.Tool{
		Name: "",
	}
	tools = append(tools, tool)

	pack := sbom.NewComponent()
	pack.Version = ""
	pack.Name = ""
	pack.Spdxid = ""
	pack.CopyRight = "NOASSERTION"
	pack.FileAnalyzed = false
	pack.ID = ""
	pack.PackageLicenseConcluded = "NONE"
	pack.PackageLicenseDeclared = "NOASSERTION"
	pack.DownloadLocation = ""

	supplier := sbom.Supplier{
		Email: "",
	}
	pack.Supplier = supplier

	checksum := sbom.Checksum{
		Alg:     "SHA-1",
		Content: "443238d9cf19f77ccc8cdda3ba5421ea9ea2bc78",
	}

	var checksums []sbom.GetChecksum
	checksums = append(checksums, checksum)
	pack.Checksums = checksums

	extRef := sbom.ExternalReference{
		RefType: "cpe23Type",
	}
