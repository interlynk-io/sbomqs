Running linter...
level=warning msg="[runner/nolint_filter] Found unknown linters in //nolint directives: stylecheck"
pkg/compliance/bsi.go:376: 376-399 lines are duplicate of `pkg/compliance/ntia.go:313-340` (dupl)
	if doc.Spec().GetSpecType() == string(sbom.SBOMSpecSPDX) {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(bsiGetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}

		dependencies = doc.GetRelationships(common.GetID(component.GetSpdxID()))
		if dependencies == nil {
			if bsiPrimaryDependencies[common.GetID(component.GetSpdxID())] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")
		}
		allDepByName = common.GetDependenciesByName(dependencies, bsiCompIDWithName)
		if bsiPrimaryDependencies[common.GetID(component.GetSpdxID())] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}
		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")

	} else if doc.Spec().GetSpecType() == string(sbom.SBOMSpecCDX) {
pkg/compliance/bsi.go:399: 399-421 lines are duplicate of `pkg/compliance/ntia.go:340-363` (dupl)
	} else if doc.Spec().GetSpecType() == string(sbom.SBOMSpecCDX) {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(bsiGetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}
		id := component.GetID()
		dependencies = doc.GetRelationships(id)
		if len(dependencies) == 0 {
			if bsiPrimaryDependencies[id] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")
		}
		allDepByName = common.GetDependenciesByName(dependencies, bsiCompIDWithName)
		if bsiPrimaryDependencies[id] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}
		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
	}
pkg/compliance/bsi_test.go:45: 45-79 lines are duplicate of `pkg/compliance/bsi_test.go:174-208` (dupl)
func TestBSIWithSbomSpecFields(t *testing.T) {
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desired
	}{
		{
			name:   "sbomWithCdxSpec",
			actual: bsiSpec(cdxDocWithSpec()),
			expected: desired{
				score:  10.0,
				result: "cyclonedx",
				key:    SBOM_SPEC,
				id:     "doc",
			},
		},
		{
			name:   "sbomWithSpdxSpec",
			actual: bsiSpec(spdxDocWithSpec()),
			expected: desired{
				score:  10.0,
				result: "spdx",
				key:    SBOM_SPEC,
				id:     "doc",
			},
		},
	}

	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/bsi_test.go:174: 174-208 lines are duplicate of `pkg/compliance/bsi_test.go:45-79` (dupl)
func TestBSIWithBuildPhaseField(t *testing.T) {
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desired
	}{
		{
			name:   "spdxSbomWithCustomLifecycle",
			actual: bsiBuildPhase(spdxDocWithLifecycles()),
			expected: desired{
				score:  0.0,
				result: "",
				key:    SBOM_BUILD,
				id:     "doc",
			},
		},
		{
			name:   "cdxSbomWithBuildLifecycle",
			actual: bsiBuildPhase(cdxDocWithLifecycles()),
			expected: desired{
				score:  10.0,
				result: "build",
				key:    SBOM_BUILD,
				id:     "doc",
			},
		},
	}

	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/ntia.go:313: 313-340 lines are duplicate of `pkg/compliance/bsi.go:376-399` (dupl)
	if doc.Spec().GetSpecType() == "spdx" {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(GetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}

		dependencies = doc.GetRelationships(common.GetID(component.GetSpdxID()))
		if dependencies == nil {

			if primaryDependencies[common.GetID(component.GetSpdxID())] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")

		}
		allDepByName = common.GetDependenciesByName(dependencies, compIDWithName)

		if primaryDependencies[common.GetID(component.GetSpdxID())] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}

		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")

	} else if doc.Spec().GetSpecType() == "cyclonedx" {
pkg/compliance/ntia.go:340: 340-363 lines are duplicate of `pkg/compliance/bsi.go:399-421` (dupl)
	} else if doc.Spec().GetSpecType() == "cyclonedx" {
		if component.GetPrimaryCompInfo().IsPresent() {
			result = strings.Join(GetAllPrimaryDepenciesByName, ", ")
			score = 10.0
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, score, "")
		}
		id := component.GetID()
		dependencies = doc.GetRelationships(id)
		if len(dependencies) == 0 {
			if primaryDependencies[id] {
				return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "included-in", 10.0, "")
			}
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), "no-relationship", 0.0, "")
		}
		allDepByName = common.GetDependenciesByName(dependencies, compIDWithName)
		if primaryDependencies[id] {
			allDepByName = append([]string{"included-in"}, allDepByName...)
			result = strings.Join(allDepByName, ", ")
			return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")
		}
		result = strings.Join(allDepByName, ", ")
		return db.NewRecordStmt(COMP_DEPTH, common.UniqueElementID(component), result, 10.0, "")

	}
pkg/compliance/ntia_report.go:101: 101-152 lines are duplicate of `pkg/compliance/oct_report.go:120-171` (dupl)
func ntiaConstructSections(db *db.DB) []ntiaSection {
	var sections []ntiaSection
	allIDs := db.GetAllIDs()
	for _, id := range allIDs {
		records := db.GetRecordsByID(id)

		for _, r := range records {
			section := ntiaSectionDetails[r.CheckKey]
			newSection := ntiaSection{
				Title:     section.Title,
				ID:        section.ID,
				DataField: section.DataField,
				Required:  section.Required,
			}
			score := ntiaKeyIDScore(db, r.CheckKey, r.ID)
			newSection.Score = score.totalScore()
			if r.ID == "doc" {
				newSection.ElementID = "sbom"
			} else {
				newSection.ElementID = r.ID
			}

			newSection.ElementResult = r.CheckValue

			sections = append(sections, newSection)
		}
	}
	// Group sections by ElementID
	sectionsByElementID := make(map[string][]ntiaSection)
	for _, section := range sections {
		sectionsByElementID[section.ElementID] = append(sectionsByElementID[section.ElementID], section)
	}

	// Sort each group of sections by section.ID and ensure "SBOM Data Fields" comes first within its group if it exists
	var sortedSections []ntiaSection
	var sbomLevelSections []ntiaSection
	for elementID, group := range sectionsByElementID {
		sort.Slice(group, func(i, j int) bool {
			return group[i].ID < group[j].ID
		})
		if elementID == "SBOM Level" {
			sbomLevelSections = group
		} else {
			sortedSections = append(sortedSections, group...)
		}
	}

	// Place "SBOM Level" sections at the top
	sortedSections = append(sbomLevelSections, sortedSections...)

	return sortedSections
}
pkg/compliance/ntia_score.go:15: 15-144 lines are duplicate of `pkg/compliance/oct_score.go:15-144` (dupl)
package compliance

import "github.com/interlynk-io/sbomqs/v2/pkg/compliance/db"

type ntiaScoreResult struct {
	id              string
	requiredScore   float64
	optionalScore   float64
	requiredRecords int
	optionalRecords int
}

func newNtiaScoreResult(id string) *ntiaScoreResult {
	return &ntiaScoreResult{id: id}
}

func (r *ntiaScoreResult) totalScore() float64 {
	if r.requiredRecords == 0 && r.optionalRecords == 0 {
		return 0.0
	}

	if r.requiredRecords != 0 && r.optionalRecords != 0 {
		return (r.totalRequiredScore() + r.totalOptionalScore()) / 2
	}

	if r.requiredRecords == 0 && r.optionalRecords != 0 {
		return r.totalOptionalScore()
	}

	return r.totalRequiredScore()
}

func (r *ntiaScoreResult) totalRequiredScore() float64 {
	if r.requiredRecords == 0 {
		return 0.0
	}

	return r.requiredScore / float64(r.requiredRecords)
}

func (r *ntiaScoreResult) totalOptionalScore() float64 {
	if r.optionalRecords == 0 {
		return 0.0
	}

	return r.optionalScore / float64(r.optionalRecords)
}

func ntiaKeyIDScore(db *db.DB, key int, id string) *ntiaScoreResult {
	records := db.GetRecordsByKeyID(key, id)

	if len(records) == 0 {
		return newNtiaScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &ntiaScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}

func ntiaAggregateScore(db *db.DB) *ntiaScoreResult {
	var results []ntiaScoreResult
	var finalResult ntiaScoreResult

	ids := db.GetAllIDs()
	for _, id := range ids {
		results = append(results, *ntiaIDScore(db, id))
	}

	for _, r := range results {
		finalResult.requiredScore += r.requiredScore
		finalResult.optionalScore += r.optionalScore
		finalResult.requiredRecords += r.requiredRecords
		finalResult.optionalRecords += r.optionalRecords
	}

	return &finalResult
}

func ntiaIDScore(db *db.DB, id string) *ntiaScoreResult {
	records := db.GetRecordsByID(id)

	if len(records) == 0 {
		return newNtiaScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &ntiaScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}
pkg/compliance/ntia_test.go:89: 89-196 lines are duplicate of `pkg/compliance/ntia_test.go:254-358` (dupl)
func TestNtiaSpdxSbomPass(t *testing.T) {
	doc := createSpdxDummyDocumentNtia()
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desiredNtia
	}{
		{
			name:   "AutomationSpec",
			actual: ntiaAutomationSpec(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "spdx, json",
				key:    SBOM_MACHINE_FORMAT,
				id:     "Automation Support",
			},
		},
		{
			name:   "SbomCreator",
			actual: ntiaSbomCreator(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "syft",
				key:    SBOM_CREATOR,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomCreatedTimestamp",
			actual: ntiaSbomCreatedTimestamp(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "2023-05-04T09:33:40Z",
				key:    SBOM_TIMESTAMP,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomDependency",
			actual: ntiaSBOMDependency(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "doc has 1 dependencies",
				key:    SBOM_DEPENDENCY,
				id:     "SBOM Data Fields",
			},
		},

		{
			name:   "ComponentCreator",
			actual: ntiaComponentCreator(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "hello@interlynk.io",
				key:    COMP_CREATOR,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},

		{
			name:   "ComponentName",
			actual: ntiaComponentName(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "tool-golang",
				key:    COMP_NAME,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentVersion",
			actual: ntiaComponentVersion(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "v0.7.1",
				key:    COMP_VERSION,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentOtherUniqIDs",
			actual: ntiaComponentOtherUniqIDs(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "purl:(1/1)",
				key:    COMP_OTHER_UNIQ_IDS,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentDependencies",
			actual: ntiaComponentDependencies(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "gordf",
				key:    COMP_DEPTH,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
	}

	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/ntia_test.go:254: 254-358 lines are duplicate of `pkg/compliance/ntia_test.go:89-196` (dupl)
func TestNtiaCdxSbomPass(t *testing.T) {
	doc := createCdxDummyDocumentNtia()
	testCases := []struct {
		name     string
		actual   *db.Record
		expected desiredNtia
	}{
		{
			name:   "AutomationSpec",
			actual: ntiaAutomationSpec(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "cyclonedx, xml",
				key:    SBOM_MACHINE_FORMAT,
				id:     "Automation Support",
			},
		},
		{
			name:   "SbomCreator",
			actual: ntiaSbomCreator(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "hello@interlynk.io",
				key:    SBOM_CREATOR,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomCreatedTimestamp",
			actual: ntiaSbomCreatedTimestamp(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "2023-05-04T09:33:40Z",
				key:    SBOM_TIMESTAMP,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "SbomDependency",
			actual: ntiaSBOMDependency(doc),
			expected: desiredNtia{
				score:  10.0,
				result: "doc has 1 dependencies",
				key:    SBOM_DEPENDENCY,
				id:     "SBOM Data Fields",
			},
		},
		{
			name:   "ComponentCreator",
			actual: ntiaComponentCreator(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "hello@interlynk.io",
				key:    COMP_CREATOR,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentName",
			actual: ntiaComponentName(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "tool-golang",
				key:    COMP_NAME,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentVersion",
			actual: ntiaComponentVersion(doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "v0.7.1",
				key:    COMP_VERSION,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentOtherUniqIDs",
			actual: ntiaComponentOtherUniqIDs(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "vivek",
				key:    COMP_OTHER_UNIQ_IDS,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
		{
			name:   "ComponentDependencies",
			actual: ntiaComponentDependencies(doc, doc.Components()[0]),
			expected: desiredNtia{
				score:  10.0,
				result: "gordf",
				key:    COMP_DEPTH,
				id:     common.UniqueElementID(doc.Components()[0]),
			},
		},
	}
	for _, test := range testCases {
		assert.Equal(t, test.expected.score, test.actual.Score, "Score mismatch for %s", test.name)
		assert.Equal(t, test.expected.key, test.actual.CheckKey, "Key mismatch for %s", test.name)
		assert.Equal(t, test.expected.id, test.actual.ID, "ID mismatch for %s", test.name)
		assert.Equal(t, test.expected.result, test.actual.CheckValue, "Result mismatch for %s", test.name)
	}
}
pkg/compliance/oct_report.go:120: 120-171 lines are duplicate of `pkg/compliance/ntia_report.go:101-152` (dupl)
func octConstructSections(dtb *db.DB) []octSection {
	var sections []octSection
	allIDs := dtb.GetAllIDs()
	for _, id := range allIDs {
		records := dtb.GetRecordsByID(id)

		for _, r := range records {
			section := octSectionDetails[r.CheckKey]
			newSection := octSection{
				Title:     section.Title,
				ID:        section.ID,
				DataField: section.DataField,
				Required:  section.Required,
			}
			score := octKeyIDScore(dtb, r.CheckKey, r.ID)
			newSection.Score = score.totalScore()
			if r.ID == "SPDX Elements" {
				newSection.ElementID = "SPDX Elements"
			} else {
				newSection.ElementID = r.ID
			}

			newSection.ElementResult = r.CheckValue

			sections = append(sections, newSection)
		}
	}
	// Group sections by ElementID
	sectionsByElementID := make(map[string][]octSection)
	for _, section := range sections {
		sectionsByElementID[section.ElementID] = append(sectionsByElementID[section.ElementID], section)
	}

	// Sort each group of sections by section.ID and ensure "SPDX Elements" comes first within its group if it exists
	var sortedSections []octSection
	var sbomLevelSections []octSection
	for elementID, group := range sectionsByElementID {
		sort.Slice(group, func(i, j int) bool {
			return group[i].ID < group[j].ID
		})
		if elementID == "SPDX Elements" {
			sbomLevelSections = group
		} else {
			sortedSections = append(sortedSections, group...)
		}
	}

	// Place "SBOM Level" sections at the top
	sortedSections = append(sbomLevelSections, sortedSections...)

	return sortedSections
}
pkg/compliance/oct_score.go:15: 15-144 lines are duplicate of `pkg/compliance/ntia_score.go:15-144` (dupl)
package compliance

import "github.com/interlynk-io/sbomqs/v2/pkg/compliance/db"

type octScoreResult struct {
	id              string
	requiredScore   float64
	optionalScore   float64
	requiredRecords int
	optionalRecords int
}

func newOctScoreResult(id string) *octScoreResult {
	return &octScoreResult{id: id}
}

func (r *octScoreResult) totalScore() float64 {
	if r.requiredRecords == 0 && r.optionalRecords == 0 {
		return 0.0
	}

	if r.requiredRecords != 0 && r.optionalRecords != 0 {
		return (r.totalRequiredScore() + r.totalOptionalScore()) / 2
	}

	if r.requiredRecords == 0 && r.optionalRecords != 0 {
		return r.totalOptionalScore()
	}

	return r.totalRequiredScore()
}

func (r *octScoreResult) totalRequiredScore() float64 {
	if r.requiredRecords == 0 {
		return 0.0
	}

	return r.requiredScore / float64(r.requiredRecords)
}

func (r *octScoreResult) totalOptionalScore() float64 {
	if r.optionalRecords == 0 {
		return 0.0
	}

	return r.optionalScore / float64(r.optionalRecords)
}

func octKeyIDScore(dtb *db.DB, key int, id string) *octScoreResult {
	records := dtb.GetRecordsByKeyID(key, id)

	if len(records) == 0 {
		return newOctScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &octScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}

func octAggregateScore(dtb *db.DB) *octScoreResult {
	var results []octScoreResult
	var finalResult octScoreResult

	ids := dtb.GetAllIDs()
	for _, id := range ids {
		results = append(results, *octIDScore(dtb, id))
	}

	for _, r := range results {
		finalResult.requiredScore += r.requiredScore
		finalResult.optionalScore += r.optionalScore
		finalResult.requiredRecords += r.requiredRecords
		finalResult.optionalRecords += r.optionalRecords
	}

	return &finalResult
}

func octIDScore(dtb *db.DB, id string) *octScoreResult {
	records := dtb.GetRecordsByID(id)

	if len(records) == 0 {
		return newOctScoreResult(id)
	}

	requiredScore := 0.0
	optionalScore := 0.0

	requiredRecs := 0
	optionalRecs := 0

	for _, r := range records {
		if r.Required {
			requiredScore += r.Score
			requiredRecs++
		} else {
			optionalScore += r.Score
			optionalRecs++
		}
	}

	return &octScoreResult{
		id:              id,
		requiredScore:   requiredScore,
		optionalScore:   optionalScore,
		requiredRecords: requiredRecs,
		optionalRecords: optionalRecs,
	}
}
pkg/compliance/oct_test.go:27: 27-88 lines are duplicate of `pkg/compliance/oct_test.go:368-429` (dupl)
func createDummyDocument() sbom.Document {
	s := sbom.NewSpec()
	s.Version = "SPDX-2.3"
	s.Format = "json"
	s.SpecType = "spdx"
	s.Name = "nano"
	s.Namespace = "https://anchore.com/syft/dir/sbomqs-6ec18b03-96cb-4951-b299-929890c1cfc8"
	s.Organization = "interlynk"
	s.CreationTimestamp = "2023-05-04T09:33:40Z"
	s.Spdxid = "DOCUMENT"
	s.Comment = "this is a general sbom created using syft tool"
	lics := licenses.CreateCustomLicense("", "cc0-1.0")
	s.Licenses = append(s.Licenses, lics)

	var tools []sbom.GetTool
	tool := sbom.Tool{
		Name: "syft",
	}
	tools = append(tools, tool)

	pack := sbom.NewComponent()
	pack.Version = "v0.7.1"
	pack.Name = "core-js"
	pack.Spdxid = "SPDXRef-npm-core-js-3.6.5"
	pack.CopyRight = "Copyright 2001-2011 The Apache Software Foundation"
	pack.FileAnalyzed = true
	pack.ID = "Package-go-module-github.com-CycloneDX-cyclonedx-go-21b8492723f5584d"
	pack.PackageLicenseConcluded = "(LGPL-2.0-only OR LicenseRef-3)"
	pack.PackageLicenseDeclared = "(LGPL-2.0-only AND LicenseRef-3)"
	pack.DownloadLocation = "https://registry.npmjs.org/core-js/-/core-js-3.6.5.tgz"

	supplier := sbom.Supplier{
		Email: "vivekkumarsahu650@gmail.com",
	}
	pack.Supplier = supplier

	checksum := sbom.Checksum{
		Alg:     "SHA256",
		Content: "ee1300ac533cebc2d070ce3765685d5f7fca2a5a78ca15068323f68ed63d4abf",
	}

	var checksums []sbom.GetChecksum
	checksums = append(checksums, checksum)
	pack.Checksums = checksums

	extRef := sbom.ExternalReference{
		RefType: "purl",
	}
	var externalReferences []sbom.GetExternalReference
	externalReferences = append(externalReferences, extRef)
	pack.ExternalRefs = externalReferences

	var packages []sbom.GetComponent
	packages = append(packages, pack)

	doc := sbom.SpdxDoc{
		SpdxSpec:  s,
		Comps:     packages,
		SpdxTools: tools,
	}
	return doc
}
pkg/compliance/oct_test.go:368: 368-429 lines are duplicate of `pkg/compliance/oct_test.go:27-88` (dupl)
func createFailureDummyDocument() sbom.Document {
	s := sbom.NewSpec()
	s.Version = ""
	s.Format = "xml"
	s.SpecType = "cyclonedx"
	s.Name = ""
	s.Namespace = ""
	s.Organization = ""
	s.CreationTimestamp = "wrong-time-format"
	s.Spdxid = ""
	s.Comment = ""
	lics := licenses.CreateCustomLicense("", "")
	s.Licenses = append(s.Licenses, lics)

	var tools []sbom.GetTool
	tool := sbom.Tool{
		Name: "",
	}
	tools = append(tools, tool)

	pack := sbom.NewComponent()
	pack.Version = ""
	pack.Name = ""
	pack.Spdxid = ""
	pack.CopyRight = "NOASSERTION"
	pack.FileAnalyzed = false
	pack.ID = ""
	pack.PackageLicenseConcluded = "NONE"
	pack.PackageLicenseDeclared = "NOASSERTION"
	pack.DownloadLocation = ""

	supplier := sbom.Supplier{
		Email: "",
	}
	pack.Supplier = supplier

	checksum := sbom.Checksum{
		Alg:     "SHA-1",
		Content: "443238d9cf19f77ccc8cdda3ba5421ea9ea2bc78",
	}

	var checksums []sbom.GetChecksum
	checksums = append(checksums, checksum)
	pack.Checksums = checksums

	extRef := sbom.ExternalReference{
		RefType: "cpe23Type",
	}
	var externalReferences []sbom.GetExternalReference
	externalReferences = append(externalReferences, extRef)
	pack.ExternalRefs = externalReferences

	var packages []sbom.GetComponent
	packages = append(packages, pack)

	doc := sbom.SpdxDoc{
		SpdxSpec:  s,
		Comps:     packages,
		SpdxTools: tools,
	}
	return doc
}
pkg/scorer/bsi.go:178: 178-206 lines are duplicate of `pkg/scorer/bsi.go:231-259` (dupl)
func compWithSourceCodeURICheck(d sbom.Document, c *check) score {
	s := newScoreFromCheck(c)

	if d.Spec().GetSpecType() == "spdx" {
		s.setScore(0.0)
		s.setDesc("no-deterministic-field in spdx")
		s.setIgnore(true)
		return *s
	}

	totalComponents := len(d.Components())
	if totalComponents == 0 {
		s.setScore(0.0)
		s.setDesc("N/A (no components)")
		s.setIgnore(true)
		return *s
	}

	withSourceCodeURI := lo.CountBy(d.Components(), func(c sbom.GetComponent) bool {
		return c.GetSourceCodeURL() != ""
	})

	if totalComponents > 0 {
		s.setScore((float64(withSourceCodeURI) / float64(totalComponents)) * 10.0)
	}

	s.setDesc(fmt.Sprintf("%d/%d have source code URI", withSourceCodeURI, totalComponents))
	return *s
}
pkg/scorer/bsi.go:231: 231-259 lines are duplicate of `pkg/scorer/bsi.go:178-206` (dupl)
func compWithSourceCodeHashCheck(d sbom.Document, c *check) score {
	s := newScoreFromCheck(c)

	if d.Spec().GetSpecType() == "cyclonedx" {
		s.setScore(0.0)
		s.setDesc("no-deterministic-field in cdx")
		s.setIgnore(true)
		return *s
	}

	totalComponents := len(d.Components())
	if totalComponents == 0 {
		s.setScore(0.0)
		s.setDesc("N/A (no components)")
		s.setIgnore(true)
		return *s
	}

	withSourceCodeHash := lo.CountBy(d.Components(), func(c sbom.GetComponent) bool {
		return c.SourceCodeHash() != ""
	})

	if totalComponents > 0 {
		s.setScore((float64(withSourceCodeHash) / float64(totalComponents)) * 10.0)
	}

	s.setDesc(fmt.Sprintf("%d/%d have source code hash", withSourceCodeHash, totalComponents))
	return *s
}
pkg/scorer/quality.go:97: 97-127 lines are duplicate of `pkg/scorer/quality.go:129-159` (dupl)
func compWithNoDepLicensesCheck(d sbom.Document, c *check) score {
	s := newScoreFromCheck(c)
	totalComponents := len(d.Components())
	if totalComponents == 0 {
		s.setScore(0.0)
		s.setDesc("N/A (no components)")
		s.setIgnore(true)
		return *s
	}

	totalLicenses := lo.Reduce(d.Components(), func(agg int, c sbom.GetComponent, _ int) int {
		return agg + len(c.GetLicenses())
	}, 0)

	withDepLicense := lo.CountBy(d.Components(), func(c sbom.GetComponent) bool {
		deps := lo.CountBy(c.GetLicenses(), func(l licenses.License) bool {
			return l.Deprecated()
		})
		return deps > 0
	})

	if totalLicenses == 0 {
		s.setScore(0.0)
		s.setDesc("no licenses found")
	} else {
		finalScore := (float64(totalComponents-withDepLicense) / float64(totalComponents)) * 10.0
		s.setScore(finalScore)
		s.setDesc(fmt.Sprintf("%d/%d components have deprecated licenses", withDepLicense, totalComponents))
	}
	return *s
}
pkg/scorer/quality.go:129: 129-159 lines are duplicate of `pkg/scorer/quality.go:97-127` (dupl)
func compWithRestrictedLicensesCheck(d sbom.Document, c *check) score {
	s := newScoreFromCheck(c)
	totalComponents := len(d.Components())
	if totalComponents == 0 {
		s.setScore(0.0)
		s.setDesc("N/A (no components)")
		s.setIgnore(true)
		return *s
	}

	totalLicenses := lo.Reduce(d.Components(), func(agg int, c sbom.GetComponent, _ int) int {
		return agg + len(c.GetLicenses())
	}, 0)

	withRestrictLicense := lo.CountBy(d.Components(), func(c sbom.GetComponent) bool {
		rest := lo.CountBy(c.GetLicenses(), func(l licenses.License) bool {
			return l.Restrictive()
		})
		return rest > 0
	})

	if totalLicenses == 0 {
		s.setScore(0.0)
		s.setDesc("no licenses found")
	} else {
		finalScore := (float64(totalComponents-withRestrictLicense) / float64(totalComponents)) * 10.0
		s.setScore(finalScore)
		s.setDesc(fmt.Sprintf("%d/%d components have restricted licenses", withRestrictLicense, totalComponents))
	}
	return *s
}
pkg/scorer/v2/extractors/completeness_test.go:180: 180-236 lines are duplicate of `pkg/scorer/v2/extractors/completeness_test.go:296-352` (dupl)
func TestCompWithSourceCode(t *testing.T) {
	t.Run("NoComponents", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{})

		got := CompWithSourceCode(doc)

		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "N/A (no components)", got.Desc)
		assert.True(t, got.Ignore)
	})

	t.Run("ComponentsWithNoSourceCodeURL", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{
			withPrimary: true,
			comps: []miniComp2{
				{id: "SPDXRef-A", name: "a", version: "1.0.0"},
				{id: "SPDXRef-B", name: "b", version: "2.0.0"},
			},
		})

		got := CompWithSourceCode(doc)

		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "add to 2 components", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("OneComponentWithSourceCodeURL", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{
			withPrimary: true,
			comps: []miniComp2{
				{id: "SPDXRef-A", name: "a", version: "1.0.0", srcURL: "https://github.com/demo/foo"},
				{id: "SPDXRef-B", name: "b", version: "2.0.0"},
			},
		})
		got := CompWithSourceCode(doc)

		assert.InDelta(t, 5.0, got.Score, 1e-9)
		assert.Equal(t, "add to 1 component", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("ALLComponentWithSourceCodeURL", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{
			withPrimary: true,
			comps: []miniComp2{
				{id: "SPDXRef-A", name: "a", version: "1.0.0", srcURL: "https://github.com/demo/foo"},
				{id: "SPDXRef-B", name: "b", version: "2.0.0", srcURL: "https://github.com/demo/bar"},
			},
		})
		got := CompWithSourceCode(doc)

		assert.InDelta(t, 10.0, got.Score, 1e-9)
		assert.Equal(t, "complete", got.Desc)
		assert.False(t, got.Ignore)
	})
}
pkg/scorer/v2/extractors/completeness_test.go:296: 296-352 lines are duplicate of `pkg/scorer/v2/extractors/completeness_test.go:180-236` (dupl)
func TestCompWithPackageType(t *testing.T) {
	t.Run("NoComponents", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{})

		got := CompWithPackagePurpose(doc)

		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "N/A (no components)", got.Desc)
		assert.True(t, got.Ignore)
	})

	t.Run("ComponentsWithNoPackageType", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{
			withPrimary: true,
			comps: []miniComp2{
				{id: "SPDXRef-A", name: "a", version: "1.0.0"},
				{id: "SPDXRef-B", name: "b", version: "2.0.0"},
			},
		})

		got := CompWithPackagePurpose(doc)

		assert.InDelta(t, 0.0, got.Score, 1e-9)
		assert.Equal(t, "add to 2 components", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("OneComponentWithPackageType", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{
			withPrimary: true,
			comps: []miniComp2{
				{id: "SPDXRef-A", name: "a", version: "1.0.0", primaryPurpose: "container"},
				{id: "SPDXRef-B", name: "b", version: "2.0.0"},
			},
		})
		got := CompWithPackagePurpose(doc)

		assert.InDelta(t, 5.0, got.Score, 1e-9)
		assert.Equal(t, "add to 1 component", got.Desc)
		assert.False(t, got.Ignore)
	})

	t.Run("ALLComponentWithPackageType", func(t *testing.T) {
		doc := makeSPDXDocForCompleteness(spdxDocOpts2{
			withPrimary: true,
			comps: []miniComp2{
				{id: "SPDXRef-A", name: "a", version: "1.0.0", primaryPurpose: "library"},
				{id: "SPDXRef-B", name: "b", version: "2.0.0", primaryPurpose: "application"},
			},
		})
		got := CompWithPackagePurpose(doc)

		assert.InDelta(t, 10.0, got.Score, 1e-9)
		assert.Equal(t, "complete", got.Desc)
		assert.False(t, got.Ignore)
	})
}
pkg/scorer/v2/extractors/licensing.go:96: 96-139 lines are duplicate of `pkg/scorer/v2/extractors/licensing.go:143-186` (dupl)
func CompWithDeprecatedLicenses(doc sbom.Document) catalog.ComprFeatScore {
	comps := doc.Components()
	if len(comps) == 0 {
		return formulae.ScoreCompNA()
	}

	// First check if any components have concluded licenses
	componentsWithConcluded := lo.CountBy(comps, func(c sbom.GetComponent) bool {
		return commonV2.ComponentHasAnyConcluded(c)
	})

	// If no components have concluded licenses, this check is not applicable
	if componentsWithConcluded == 0 {
		return catalog.ComprFeatScore{
			Score:  formulae.BooleanScore(false),
			Desc:   "add concluded licenses first",
			Ignore: false,
		}
	}

	// Count components that HAVE deprecated licenses (problematic)
	withDeprecated := lo.CountBy(comps, func(c sbom.GetComponent) bool {
		return commonV2.ComponentHasAnyDeprecated(c)
	})

	// Components WITHOUT deprecated licenses (good)
	withoutDeprecated := len(comps) - withDeprecated

	var description string
	if withDeprecated == 0 {
		description = "complete"
	} else if withDeprecated == 1 {
		description = "fix 1 component"
	} else {
		description = fmt.Sprintf("fix %d components", withDeprecated)
	}

	// Score based on components WITHOUT deprecated licenses
	return catalog.ComprFeatScore{
		Score:  formulae.PerComponentScore(withoutDeprecated, len(comps)),
		Desc:   description,
		Ignore: false,
	}
}
pkg/scorer/v2/extractors/licensing.go:143: 143-186 lines are duplicate of `pkg/scorer/v2/extractors/licensing.go:96-139` (dupl)
func CompWithRestrictiveLicenses(doc sbom.Document) catalog.ComprFeatScore {
	comps := doc.Components()
	if len(comps) == 0 {
		return formulae.ScoreCompNA()
	}

	// First check if any components have concluded licenses
	componentsWithConcluded := lo.CountBy(comps, func(c sbom.GetComponent) bool {
		return commonV2.ComponentHasAnyConcluded(c)
	})

	// If no components have concluded licenses, this check is not applicable
	if componentsWithConcluded == 0 {
		return catalog.ComprFeatScore{
			Score:  formulae.BooleanScore(false),
			Desc:   "add concluded licenses first",
			Ignore: false,
		}
	}

	// Count components that HAVE restrictive licenses (problematic)
	withRestrictive := lo.CountBy(comps, func(c sbom.GetComponent) bool {
		return commonV2.ComponentHasAnyRestrictive(c)
	})

	// Components WITHOUT restrictive licenses (good)
	withoutRestrictive := len(comps) - withRestrictive

	var description string
	if withRestrictive == 0 {
		description = "complete"
	} else if withRestrictive == 1 {
		description = "review 1 component"
	} else {
		description = fmt.Sprintf("review %d components", withRestrictive)
	}

	// Score based on components WITHOUT restrictive licenses
	return catalog.ComprFeatScore{
		Score:  formulae.PerComponentScore(withoutRestrictive, len(comps)),
		Desc:   description,
		Ignore: false,
	}
}
pkg/scorer/v2/extractors/structural_test.go:73: 73-100 lines are duplicate of `pkg/scorer/v2/extractors/structural_test.go:102-129` (dupl)
func Test_SBOMSpecVersion(t *testing.T) {
	t.Run("SupportedSPDXVersion", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxSpecForStructural("SPDX-2.3", "json", "spdx")}

		got := SBOMSpecVersion(doc)

		assert.Equal(t, 10.0, got.Score)
		assert.Equal(t, "SPDX-2.3", got.Desc)
	})

	t.Run("UnSupportedSPDXVersion", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxSpecForStructural("SPDX-100.3", "json", "spdx")}

		got := SBOMSpecVersion(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported version: SPDX-100.3 (spec spdx)", got.Desc)
	})

	t.Run("UnsupportedCDXVersion", func(t *testing.T) {
		doc := sbom.CdxDoc{CdxSpec: cdxSpecForStructural("9.9", "json", "cyclonedx")}

		got := SBOMSpecVersion(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported version: 9.9 (spec cyclonedx)", got.Desc)
	})
}
pkg/scorer/v2/extractors/structural_test.go:102: 102-129 lines are duplicate of `pkg/scorer/v2/extractors/structural_test.go:73-100` (dupl)
func Test_SBOMFileFormat(t *testing.T) {
	t.Run("SupportedFormatForSPDX", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxSpecForStructural("SPDX-2.3", "json", "spdx")}

		got := SBOMFileFormat(doc)

		assert.Equal(t, 10.0, got.Score)
		assert.Equal(t, "json", got.Desc)
	})

	t.Run("UnsupportedFormatForSPDX", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxSpecForStructural("SPDX-2.3", "pdf", "spdx")}

		got := SBOMFileFormat(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported format: pdf (spec spdx)", got.Desc)
	})

	t.Run("UnsupportedFormat", func(t *testing.T) {
		doc := sbom.CdxDoc{CdxSpec: cdxSpecForStructural("1.4", "ppl", "cyclonedx")}

		got := SBOMFileFormat(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported format: ppl (spec cyclonedx)", got.Desc)
	})
}
pkg/scorer/v2/profiles/common_test.go:82: 82-109 lines are duplicate of `pkg/scorer/v2/profiles/common_test.go:111-138` (dupl)
func Test_SBOMSpecVersion(t *testing.T) {
	t.Run("SupportedSPDXVersion", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxDocSpec("SPDX-2.3", "json", "spdx")}

		got := SBOMSpecVersion(doc)

		assert.Equal(t, 10.0, got.Score)
		assert.Equal(t, "complete", got.Desc)
	})

	t.Run("UnSupportedSPDXVersion", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxDocSpec("SPDX-100.3", "json", "spdx")}

		got := SBOMSpecVersion(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported spec version: SPDX-100.3 (spec spdx)", got.Desc)
	})

	t.Run("UnsupportedCDXVersion", func(t *testing.T) {
		doc := sbom.CdxDoc{CdxSpec: cdxDocSpec("9.9", "json", "cyclonedx")}

		got := SBOMSpecVersion(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported spec version: 9.9 (spec cyclonedx)", got.Desc)
	})
}
pkg/scorer/v2/profiles/common_test.go:111: 111-138 lines are duplicate of `pkg/scorer/v2/profiles/common_test.go:82-109` (dupl)
func Test_SBOMFileFormat(t *testing.T) {
	t.Run("SupportedFormatForSPDX", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxDocSpec("SPDX-2.3", "json", "spdx")}

		got := SBOMAutomationSpec(doc)

		assert.Equal(t, 10.0, got.Score)
		assert.Equal(t, "complete", got.Desc)
	})

	t.Run("UnsupportedFormatForSPDX", func(t *testing.T) {
		doc := sbom.SpdxDoc{SpdxSpec: spdxDocSpec("SPDX-2.3", "pdf", "spdx")}

		got := SBOMAutomationSpec(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported file format: pdf (spec spdx)", got.Desc)
	})

	t.Run("UnsupportedFormat", func(t *testing.T) {
		doc := sbom.CdxDoc{CdxSpec: cdxDocSpec("1.4", "ppl", "cyclonedx")}

		got := SBOMAutomationSpec(doc)

		assert.Equal(t, 0.0, got.Score)
		assert.Equal(t, "unsupported file format: ppl (spec cyclonedx)", got.Desc)
	})
}
pkg/scorer/v2/registry/registry.go:138: 138-175 lines are duplicate of `pkg/scorer/v2/registry/registry.go:177-214` (dupl)
var InterlynkKeyToEvaluatingFunction = map[string]catalog.ProfFeatEval{
	"comp_name":     profiles.InterCompWithName,
	"comp_version":  profiles.InterCompWithVersion,
	"comp_local_id": profiles.InterCompWithUniqueID,

	"sbom_timestamp": profiles.InterSBOMTimestamp,
	"sbom_authors":   profiles.InterSBOMAuthors,
	"sbom_tool":      profiles.InterSBOMTOol,
	"sbom_supplier":  profiles.InterSBOMSupplier,
	"sbom_namespace": profiles.InterSBOMNamespace,
	"sbom_lifecycle": profiles.InterSBOMLifecycle,

	"comp_checksums": profiles.InterCompWithChecksum,
	"comp_sha256":    profiles.InterCompWithChecksum265,
	"sbom_signature": profiles.InterSBOMSignature,

	"comp_dependencies":      profiles.InterCompWithDependencies,
	"sbom_completeness":      profiles.InterSBOMCompleteness,
	"sbom_primary_component": profiles.InterSBOMPrimaryComponent,
	"comp_source_code":       profiles.InterCompWithSourceCode,
	"comp_supplier":          profiles.InterCompWithSupplier,
	"comp_purpose":           profiles.InterCompWithPurpose,

	"comp_licenses":                profiles.InterCompWithLicenses,
	"comp_valid_licenses":          profiles.InterCompWithValidLicenses,
	"comp_no_deprecated_licenses":  profiles.InterCompWithNODeprecatedLicenses,
	"comp_no_restrictive_licenses": profiles.InterCompWithNORestrictiveLicenses,
	"comp_declared_licenses":       profiles.InterCompWithDeclaredLicenses,
	"sbom_data_license":            profiles.InterSBOMDataLicenses,

	"comp_purl": profiles.InterCompWithPURL,
	"comp_cpe":  profiles.InterCompWithCPE,

	"sbom_spec_declared": profiles.InterSBOMSpec,
	"sbom_spec_version":  profiles.InterSBOMSpecVersion,
	"sbom_file_format":   profiles.InterSBOMFileFormat,
	"sbom_schema_valid":  profiles.InterSBOMSchema,
}
pkg/scorer/v2/registry/registry.go:177: 177-214 lines are duplicate of `pkg/scorer/v2/registry/registry.go:138-175` (dupl)
var CompKeyToEvaluatingFunction = map[string]catalog.ComprFeatEval{
	"comp_with_name":     extractors.CompWithName,
	"comp_with_version":  extractors.CompWithVersion,
	"comp_with_local_id": extractors.CompWithUniqLocalIDs,

	"sbom_creation_timestamp": extractors.SBOMCreationTimestamp,
	"sbom_authors":            extractors.SBOMAuthors,
	"sbom_tool_version":       extractors.SBOMCreationTool,
	"sbom_supplier":           extractors.SBOMSupplier,
	"sbom_namespace":          extractors.SBOMNamespace,
	"sbom_lifecycle":          extractors.SBOMLifeCycle,

	"comp_with_strong_checksums": extractors.CompWithStrongChecksums,
	"comp_with_weak_checksums":   extractors.CompWithWeakChecksums,
	"sbom_signature":             extractors.SBOMSignature,

	"comp_with_dependencies":     extractors.CompWithDependencies,
	"sbom_completeness_declared": extractors.CompWithCompleteness,
	"sbom_primary_component":     extractors.SBOMWithPrimaryComponent,
	"comp_with_source_code":      extractors.CompWithSourceCode,
	"comp_with_supplier":         extractors.CompWithSupplier,
	"comp_with_purpose":          extractors.CompWithPackagePurpose,

	"comp_with_licenses":           extractors.CompWithLicenses,
	"comp_with_valid_licenses":     extractors.CompWithValidLicenses,
	"comp_no_deprecated_licenses":  extractors.CompWithDeprecatedLicenses,
	"comp_no_restrictive_licenses": extractors.CompWithRestrictiveLicenses,
	"comp_with_declared_licenses":  extractors.CompWithDeclaredLicenses,
	"sbom_data_license":            extractors.SBOMDataLicense,

	"comp_with_purl": extractors.CompWithPURL,
	"comp_with_cpe":  extractors.CompWithCPE,

	"sbom_spec_declared": extractors.SBOMWithSpec,
	"sbom_spec_version":  extractors.SBOMSpecVersion,
	"sbom_file_format":   extractors.SBOMFileFormat,
	"sbom_schema_valid":  extractors.SBOMSchemaValid,
}
pkg/scorer/v2/registry/registry.go:761: 761-790 lines are duplicate of `pkg/scorer/v2/registry/registry.go:792-823` (dupl)
var profileBSI20Spec = catalog.ProfSpec{
	Key:         ProfileBSI20,
	Name:        "BSI TR-03183-2 v2.0",
	Description: "BSI TR-03183-2 v2.0 Profile",
	Features: []catalog.ProfFeatSpec{
		{Key: "sbom_spec", Name: "SBOM Formats", Required: true, Description: "SPDX or CycloneDX", Evaluate: profiles.SBOMSpec},
		{Key: "sbom_spec_version", Name: "SBOM Spec Version", Required: true, Description: "Valid supported version", Evaluate: profiles.BSISBOMSpecVersion},
		{Key: "sbom_build", Name: "Build Information", Required: false, Description: "Build phase indication", Evaluate: profiles.BSISBOMBuildLifecycle},
		{Key: "sbom_depth", Name: "SBOM Depth", Required: true, Description: "Complete dependency tree", Evaluate: profiles.SBOMDepedencies},
		{Key: "sbom_creator", Name: "Creator Info", Required: true, Description: "Contact email/URL", Evaluate: profiles.SBOMAuthors},
		{Key: "sbom_timestamp", Name: "Creation Time", Required: true, Description: "Valid timestamp (ISO-8601)", Evaluate: profiles.SBOMCreationTimestamp},
		{Key: "sbom_uri", Name: "URI/Namespace", Required: true, Description: "Unique SBOM identifier", Evaluate: profiles.BSISBOMNamespace},

		{Key: "comp_name", Name: "Component Name", Required: true, Description: "All components named", Evaluate: profiles.CompName},
		{Key: "comp_version", Name: "Component Version", Required: true, Description: "Version for each component", Evaluate: profiles.CompVersion},

		{Key: "comp_license", Name: "Component License", Required: true, Description: "License information", Evaluate: profiles.BSICompWithLicenses},
		{Key: "comp_hash", Name: "Component Hash", Required: true, Description: "Checksums for components", Evaluate: profiles.BSICompWithHash},
		{Key: "comp_source_code_url", Name: "Component Source URL", Required: false, Description: "Source code repository", Evaluate: profiles.BSICompWithSourceCodeURI},
		{Key: "comp_download_url", Name: "Component Download URL", Required: true, Description: "Where to obtain component", Evaluate: profiles.BSICompWithDownloadURI},
		{Key: "comp_source_hash", Name: "Component Source Hash", Required: false, Description: "Hash of source code", Evaluate: profiles.BSICompWithSourceCodeHash},
		{Key: "comp_depth", Name: "Component Dependencies", Required: true, Description: "Dependency relationships", Evaluate: profiles.BSICompWithDependency},

		{Key: "sbom_signature", Name: "Digital Signature", Required: true, Description: "Cryptographic signature verification", Evaluate: profiles.BSISBOMWithSignature},
		{Key: "sbom_bomlinks", Name: "External References", Required: false, Description: "Links to other SBOMs", Evaluate: profiles.BSISBOMWithBomLinks},
		{Key: "sbom_vulnerabilities", Name: "Vulnerability Info", Required: false, Description: "Known vulnerabilities (absence preferred)", Evaluate: profiles.BSISBOMWithVulnerabilities},
		{Key: "comp_hash_sha256", Name: "SHA-256 Checksums", Required: true, Description: "SHA-256 or stronger required", Evaluate: profiles.CompSHA256Plus},
		{Key: "comp_associated_license", Name: "License Validation", Required: true, Description: "Valid SPDX license identifiers", Evaluate: profiles.BSICompWithAssociatedLicenses},
	},
}
pkg/scorer/v2/registry/registry.go:792: 792-823 lines are duplicate of `pkg/scorer/v2/registry/registry.go:761-790` (dupl)
var profileOCTV11Spec = catalog.ProfSpec{
	Key:         ProfileOCTV11,
	Name:        "OpenChain Telco v1.1",
	Description: "OpenChain Telco SBOM Guide v1.1 Profile",
	Features: []catalog.ProfFeatSpec{
		// Document Creation Information - SHALL
		{Key: "sbom_spec", Name: "SBOM Format", Required: true, Description: "SPDX or CycloneDX format", Evaluate: profiles.OCTV11SBOMSpec},
		{Key: "sbom_spec_version", Name: "Spec Version", Required: true, Description: "Valid spec version", Evaluate: profiles.OCTV11SBOMSpecVersion},
		{Key: "sbom_data_license", Name: "Data License", Required: true, Description: "License for SBOM data", Evaluate: profiles.OCTV11SBOMDataLicense},
		{Key: "sbom_identifier", Name: "Document Identifier", Required: true, Description: "SPDX ID or serial number", Evaluate: profiles.OCTV11SBOMIdentifier},
		{Key: "sbom_name", Name: "Document Name", Required: true, Description: "SBOM document name", Evaluate: profiles.OCTV11SBOMName},
		{Key: "sbom_namespace", Name: "Document Namespace", Required: true, Description: "Unique namespace URI", Evaluate: profiles.OCTV11SBOMNamespace},
		{Key: "sbom_creator", Name: "Creator", Required: true, Description: "Organization and tool info", Evaluate: profiles.OCTV11SBOMCreator},
		{Key: "sbom_timestamp", Name: "Created Timestamp", Required: true, Description: "ISO 8601 creation time", Evaluate: profiles.OCTV11SBOMTimestamp},
		{Key: "sbom_creator_comment", Name: "Creator Comment", Required: true, Description: "Build information or lifecycle", Evaluate: profiles.OCTV11SBOMCreatorComment},

		// Package Information - SHALL
		{Key: "comp_name", Name: "Package Name", Required: true, Description: "All components named", Evaluate: profiles.OCTV11CompName},
		{Key: "comp_identifier", Name: "Package Identifier", Required: true, Description: "SPDX ID or bom-ref", Evaluate: profiles.OCTV11CompIdentifier},
		{Key: "comp_version", Name: "Package Version", Required: true, Description: "Version for each component", Evaluate: profiles.OCTV11CompVersion},
		{Key: "comp_supplier", Name: "Package Supplier", Required: true, Description: "Component supplier info", Evaluate: profiles.OCTV11CompSupplier},
		{Key: "comp_download_location", Name: "Download Location", Required: true, Description: "Where to obtain component", Evaluate: profiles.OCTV11CompDownloadLocation},
		{Key: "comp_license_concluded", Name: "License Concluded", Required: true, Description: "Concluded license info", Evaluate: profiles.OCTV11CompLicenseConcluded},
		{Key: "comp_license_declared", Name: "License Declared", Required: true, Description: "Declared license info", Evaluate: profiles.OCTV11CompLicenseDeclared},
		{Key: "comp_copyright", Name: "Copyright Text", Required: true, Description: "Copyright information", Evaluate: profiles.OCTV11CompCopyright},
		{Key: "sbom_relationships", Name: "Relationships", Required: true, Description: "Dependencies and relationships", Evaluate: profiles.OCTV11SBOMRelationships},

		// Package Information - SHOULD
		{Key: "comp_checksum", Name: "Package Checksum", Required: false, Description: "Component checksums", Evaluate: profiles.OCTV11CompChecksum},
		{Key: "comp_purl", Name: "Package URL (PURL)", Required: false, Description: "Package URL identifier", Evaluate: profiles.OCTV11CompPURL},
	},
}
pkg/engine/compliance.go:145:16: Error return value of `f.Close` is not checked (errcheck)
		defer f.Close()
		             ^
pkg/engine/dtrack.go:86:17: Error return value of `f.Close` is not checked (errcheck)
			defer f.Close()
			             ^
pkg/engine/dtrack.go:87:19: Error return value of `os.Remove` is not checked (errcheck)
			defer os.Remove(f.Name())
			               ^
pkg/engine/score.go:165:23: Error return value of `resp.Body.Close` is not checked (errcheck)
	defer resp.Body.Close()
	                     ^
pkg/engine/score.go:332:16: Error return value of `f.Close` is not checked (errcheck)
		defer f.Close()
		             ^
pkg/engine/score.go:354:16: Error return value of `f.Close` is not checked (errcheck)
		defer f.Close()
		             ^
pkg/list/list.go:151:15: Error return value of `f.Close` is not checked (errcheck)
	defer f.Close()
	             ^
pkg/policy/reporter.go:57:13: Error return value of `fmt.Fprintf` is not checked (errcheck)
	fmt.Fprintf(os.Stdout, "\n\033[36m \t\t\t BASIC POLICY REPORT\033[36m\n")
	           ^
pkg/policy/reporter.go:88:13: Error return value of `fmt.Fprintf` is not checked (errcheck)
	fmt.Fprintf(os.Stdout, "\n\033[1m DETAILED POLICY REPORT\033[0m\n")
	           ^
pkg/policy/reporter.go:93:14: Error return value of `fmt.Fprintf` is not checked (errcheck)
		fmt.Fprintf(os.Stdout, "\n\033[1mPolicy: %s (result=%s, violations=%d, total_checks=%d, components=%d, total_rules_applied=%d)\033[0m\n",
		           ^
pkg/policy/reporter.go:177:13: Error return value of `fmt.Fprintf` is not checked (errcheck)
	fmt.Fprintf(os.Stdout, "\n\033[1m\033[32m \t\t--- SUMMARY TABLE ---\033[1m\n")
	           ^
pkg/reporter/v2/reporter.go:42:15: Error return value of `r.jsonReport` is not checked (errcheck)
		r.jsonReport()
		            ^
pkg/sbom/cdx.go:899:13: Error return value of `fmt.Sscanf` is not checked (errcheck)
		fmt.Sscanf(parts[0], "%d", &major)
		          ^
pkg/sbom/cdx.go:900:13: Error return value of `fmt.Sscanf` is not checked (errcheck)
		fmt.Sscanf(parts[1], "%d", &minor)
		          ^
pkg/scorer/config.go:152:15: Error return value of `f.Close` is not checked (errcheck)
	defer f.Close()
	             ^
pkg/scorer/v2/score/resolver.go:55:16: Error return value of `tmpFile.Close` is not checked (errcheck)
		tmpFile.Close()
		             ^
pkg/scorer/v2/score/resolver.go:56:12: Error return value of `os.Remove` is not checked (errcheck)
		os.Remove(tmpFile.Name())
		         ^
pkg/scorer/v2/score/resolver.go:62:16: Error return value of `tmpFile.Close` is not checked (errcheck)
		tmpFile.Close()
		             ^
pkg/scorer/v2/score/resolver.go:63:12: Error return value of `os.Remove` is not checked (errcheck)
		os.Remove(tmpFile.Name())
		         ^
pkg/scorer/v2/score/score.go:87:18: Error return value of `file.Close` is not checked (errcheck)
	defer file.Close()
	                ^
pkg/scorer/v2/score/score.go:119:10: Error return value of `f.Close` is not checked (errcheck)
		f.Close()
		       ^
pkg/scorer/v2/score/score.go:125:10: Error return value of `f.Close` is not checked (errcheck)
		f.Close()
		       ^
pkg/share/share.go:65:23: Error return value of `resp.Body.Close` is not checked (errcheck)
	defer resp.Body.Close()
	                     ^
pkg/utils/handler.go:109:23: Error return value of `resp.Body.Close` is not checked (errcheck)
	defer resp.Body.Close()
	                     ^
pkg/compliance/bsi.go:215:1: cognitive complexity 46 of func `bsiCreator` is high (> 30) (gocognit)
func bsiCreator(doc sbom.Document) *db.Record {
^
pkg/compliance/bsi.go:537:1: cognitive complexity 42 of func `bsiComponentCreator` is high (> 30) (gocognit)
func bsiComponentCreator(component sbom.GetComponent) *db.Record {
^
pkg/compliance/ntia.go:93:1: cognitive complexity 33 of func `ntiaSbomCreator` is high (> 30) (gocognit)
func ntiaSbomCreator(doc sbom.Document) *db.Record {
^
pkg/engine/dtrack.go:50:1: cognitive complexity 38 of func `DtrackScore` is high (> 30) (gocognit)
func DtrackScore(ctx context.Context, dtP *DtParams) error {
^
pkg/engine/score.go:188:1: cognitive complexity 45 of func `handlePaths` is high (> 30) (gocognit)
func handlePaths(ctx context.Context, ep *Params) error {
^
pkg/engine/score.go:307:1: cognitive complexity 50 of func `processFile` is high (> 30) (gocognit)
func processFile(ctx context.Context, ep *Params, path string, fs billy.Filesystem) (sbom.Document, scorer.Scores, error) {
^
pkg/list/report.go:101:1: cognitive complexity 36 of func `(*Report).detailedReport` is high (> 30) (gocognit)
func (r *Report) detailedReport() {
^
pkg/policy/evaluator.go:26:1: cognitive complexity 33 of func `EvaluatePolicyAgainstSBOMs` is high (> 30) (gocognit)
func EvaluatePolicyAgainstSBOMs(ctx context.Context, policy Policy, doc sbom.Document, fieldExtractor *Extractor) (PolicyResult, error) {
^
pkg/policy/extractor.go:43:1: cognitive complexity 73 of func `(*Extractor).MapFieldWithFunction` is high (> 30) (gocognit)
func (extractor *Extractor) MapFieldWithFunction(ctx context.Context) {
^
pkg/policy/reporter.go:79:1: cognitive complexity 31 of func `ReportTable` is high (> 30) (gocognit)
func ReportTable(ctx context.Context, results []PolicyResult) error {
^
pkg/reporter/v2/detailed.go:32:1: cognitive complexity 117 of func `(*Reporter).detailedReport` is high (> 30) (gocognit)
func (r *Reporter) detailedReport() {
^
pkg/sbom/cdx.go:396:1: cognitive complexity 40 of func `copyC` is high (> 30) (gocognit)
func copyC(cdxc *cydx.Component, c *CdxDoc) *Component {
^
pkg/scorer/v2/profiles/ntia_2025.go:157:1: cognitive complexity 34 of func `NTIA2025CompLicense` is high (> 30) (gocognit)
func NTIA2025CompLicense(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/ntia_2025.go:219:1: cognitive complexity 32 of func `NTIA2025CompSoftwareIdentifiers` is high (> 30) (gocognit)
func NTIA2025CompSoftwareIdentifiers(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/compliance/bsi.go:110:18: string `basic` has 4 occurrences, make it a constant (goconst)
	if outFormat == "basic" {
	                ^
pkg/compliance/bsi.go:114:18: string `detailed` has 4 occurrences, make it a constant (goconst)
	if outFormat == "detailed" {
	                ^
pkg/compliance/bsi_test.go:29:18: string `cyclonedx` has 8 occurrences, make it a constant (goconst)
	spec.SpecType = "cyclonedx"
	                ^
pkg/compliance/bsi_test.go:38:18: string `spdx` has 8 occurrences, make it a constant (goconst)
	spec.SpecType = "spdx"
	                ^
pkg/compliance/bsi_test.go:216:22: string `person` has 3 occurrences, make it a constant (goconst)
	author.AuthorType = "person"
	                    ^
pkg/compliance/common/sig.go:180:15: string `cyclonedx` has 5 occurrences, make it a constant (goconst)
	if format == "cyclonedx" {
	             ^
pkg/compliance/common/sig.go:187:22: string `spdx` has 6 occurrences, make it a constant (goconst)
	} else if format == "spdx" {
	                    ^
pkg/compliance/fsct/fsct_report.go:255:7: string `None` has 14 occurrences, make it a constant (goconst)
	case "None":
	     ^
pkg/compliance/fsct/fsct_report.go:257:7: string `Minimum` has 13 occurrences, make it a constant (goconst)
	case "Minimum":
	     ^
pkg/compliance/fsct/fsct_report.go:259:7: string `Recommended` has 5 occurrences, make it a constant (goconst)
	case "Recommended":
	     ^
pkg/compliance/fsct/fsct_report.go:261:7: string `Aspirational` has 3 occurrences, make it a constant (goconst)
	case "Aspirational":
	     ^
pkg/compliance/fsct/fsct_test.go:42:16: string `Samantha Wright` has 5 occurrences, make it a constant (goconst)
	author.Name = "Samantha Wright"
	              ^
pkg/compliance/fsct/fsct_test.go:43:22: string `person` has 7 occurrences, make it a constant (goconst)
	author.AuthorType = "person"
	                    ^
pkg/compliance/fsct/fsct_test.go:44:17: string `samantha.wright@example.com` has 3 occurrences, make it a constant (goconst)
	author.Email = "samantha.wright@example.com"
	               ^
pkg/compliance/fsct/fsct_test.go:45:17: string `800-555-1212` has 3 occurrences, make it a constant (goconst)
	author.Phone = "800-555-1212"
	               ^
pkg/compliance/fsct/fsct_test.go:98:14: string `sbom-tool` has 3 occurrences, make it a constant (goconst)
	tool.Name = "sbom-tool"
	            ^
pkg/compliance/fsct/fsct_test.go:99:17: string `9.1.2` has 3 occurrences, make it a constant (goconst)
	tool.Version = "9.1.2"
	               ^
pkg/compliance/fsct/fsct_test.go:116:21: string `syft` has 3 occurrences, make it a constant (goconst)
	serviceTool.Name = "syft"
	                   ^
pkg/compliance/fsct/fsct_test.go:344:16: string `Jane Doe` has 4 occurrences, make it a constant (goconst)
	author.Name = "Jane Doe"
	              ^
pkg/compliance/fsct/fsct_test.go:403:17: string `SPDXRef-DocumentRoot-File-sbomqs-linux-amd64` has 5 occurrences, make it a constant (goconst)
	primary.Name = "SPDXRef-DocumentRoot-File-sbomqs-linux-amd64"
	               ^
pkg/compliance/fsct/fsct_test.go:486:10: string `github.com/google/uuid` has 10 occurrences, make it a constant (goconst)
	name := "github.com/google/uuid"
	        ^
pkg/compliance/fsct/fsct_test.go:545:14: string `Acme, Inc` has 3 occurrences, make it a constant (goconst)
	supp.Name = "Acme, Inc"
	            ^
pkg/compliance/fsct/fsct_test.go:557:13: string `https://example.com` has 3 occurrences, make it a constant (goconst)
	supp.URL = "https://example.com"
	           ^
pkg/compliance/fsct/fsct_test.go:814:12: string `SHA1` has 4 occurrences, make it a constant (goconst)
	ck2.Alg = "SHA1"
	          ^
pkg/compliance/fsct/fsct_test.go:815:16: string `85ed0817af83a24ad8da68c2b5094de69833983c` has 4 occurrences, make it a constant (goconst)
	ck2.Content = "85ed0817af83a24ad8da68c2b5094de69833983c"
	              ^
pkg/compliance/fsct/fsct_test.go:1007:10: string `custom+46261/git@github.com:viveksahu26/sbomqs.git$14e7376fa2b00c102a9ba89fd5ccc7cf26f2f255` has 3 occurrences, make it a constant (goconst)
	pc.ID = "custom+46261/git@github.com:viveksahu26/sbomqs.git$14e7376fa2b00c102a9ba89fd5ccc7cf26f2f255"
	        ^
pkg/compliance/fsct/fsct_test.go:1012:12: string `pkg:github/google/go-github@0a6474043f9f14c77ba6fa77d1b377a7538a4c8c` has 3 occurrences, make it a constant (goconst)
	comp.ID = "pkg:github/google/go-github@0a6474043f9f14c77ba6fa77d1b377a7538a4c8c"
	          ^
pkg/compliance/fsct/fsct_test.go:1013:14: string `go-github` has 6 occurrences, make it a constant (goconst)
	comp.Name = "go-github"
	            ^
pkg/compliance/fsct/fsct_test.go:1016:18: string `cyclonedx` has 4 occurrences, make it a constant (goconst)
	spec.SpecType = "cyclonedx"
	                ^
pkg/compliance/fsct/fsct_test.go:1068:33: string `go-crypto` has 3 occurrences, make it a constant (goconst)
	CompIDWithName[rel2.RefB.ID] = "go-crypto"
	                               ^
pkg/compliance/fsct/fsct_test.go:1149:14: string `packageurl-go` has 7 occurrences, make it a constant (goconst)
	comp.Name = "packageurl-go"
	            ^
pkg/compliance/fsct/fsct_test.go:1155:18: string `spdx` has 4 occurrences, make it a constant (goconst)
	spec.SpecType = "spdx"
	                ^
pkg/compliance/ntia_test.go:31:13: string `json` has 8 occurrences, make it a constant (goconst)
	s.Format = "json"
	           ^
pkg/compliance/ntia_test.go:32:24: string `2023-05-04T09:33:40Z` has 3 occurrences, make it a constant (goconst)
	s.CreationTimestamp = "2023-05-04T09:33:40Z"
	                      ^
pkg/compliance/ntia_test.go:41:17: string `v0.7.1` has 3 occurrences, make it a constant (goconst)
	pack.Version = "v0.7.1"
	               ^
pkg/compliance/oct.go:247:19: string `unknown` has 3 occurrences, make it a constant (goconst)
	result, score := "unknown", 0.0
	                 ^
pkg/compliance/oct_report.go:136:15: string `SPDX Elements` has 3 occurrences, make it a constant (goconst)
			if r.ID == "SPDX Elements" {
			           ^
pkg/compliance/oct_test.go:392:19: string `NOASSERTION` has 5 occurrences, make it a constant (goconst)
	pack.CopyRight = "NOASSERTION"
	                 ^
pkg/compliance/oct_test.go:395:33: string `NONE` has 4 occurrences, make it a constant (goconst)
	pack.PackageLicenseConcluded = "NONE"
	                               ^
pkg/engine/compliance.go:65:15: string `basic` has 4 occurrences, make it a constant (goconst)
		outFormat = "basic"
		            ^
pkg/engine/compliance.go:67:15: string `json` has 4 occurrences, make it a constant (goconst)
		outFormat = "json"
		            ^
pkg/engine/compliance.go:69:15: string `detailed` has 4 occurrences, make it a constant (goconst)
		outFormat = "detailed"
		            ^
pkg/licenses/license.go:106:39: string `noassertion` has 3 occurrences, make it a constant (goconst)
	if lowerKey == "none" || lowerKey == "noassertion" {
	                                     ^
pkg/list/doceval.go:35:17: string `missing` has 61 occurrences, make it a constant (goconst)
		return false, "missing", nil
		              ^
pkg/list/doceval.go:72:17: string `no-deterministic-field in spdx` has 5 occurrences, make it a constant (goconst)
		return false, "no-deterministic-field in spdx", nil
		              ^
pkg/policy/evaluator.go:69:14: string `pass` has 4 occurrences, make it a constant (goconst)
			result := "pass"
			          ^
pkg/policy/evaluator.go:76:15: string `fail` has 5 occurrences, make it a constant (goconst)
					result = "fail"
					         ^
pkg/policy/evaluator.go:132:8: string `warn` has 3 occurrences, make it a constant (goconst)
		case "warn":
		     ^
pkg/reporter/v2/detailed.go:58:30: string `compinfo` has 5 occurrences, make it a constant (goconst)
				isCompInfo := cat.Key == "compinfo"
				                         ^
pkg/scorer/bsi.go:181:31: string `spdx` has 4 occurrences, make it a constant (goconst)
	if d.Spec().GetSpecType() == "spdx" {
	                             ^
pkg/scorer/v2/extractors/integrity.go:85:10: string `complete` has 4 occurrences, make it a constant (goconst)
		desc = "complete"
		       ^
pkg/scorer/v2/extractors/licensing_test.go:54:14: string `1.6` has 3 occurrences, make it a constant (goconst)
	s.Version = "1.6"
	            ^
pkg/scorer/v2/extractors/licensing_test.go:55:15: string `cyclonedx` has 5 occurrences, make it a constant (goconst)
	s.SpecType = "cyclonedx"
	             ^
pkg/scorer/v2/extractors/licensing_test.go:56:13: string `json` has 11 occurrences, make it a constant (goconst)
	s.Format = "json"
	           ^
pkg/scorer/v2/extractors/licensing_test.go:116:10: string `urn:uuid:11111111-2222-3333-4444-555555555555` has 3 occurrences, make it a constant (goconst)
	s.URI = "urn:uuid:11111111-2222-3333-4444-555555555555"
	        ^
pkg/scorer/v2/extractors/licensing_test.go:156:14: string `SPDX-2.3` has 6 occurrences, make it a constant (goconst)
	s.Version = "SPDX-2.3"
	            ^
pkg/scorer/v2/extractors/licensing_test.go:157:15: string `spdx` has 6 occurrences, make it a constant (goconst)
	s.SpecType = "spdx"
	             ^
pkg/scorer/v2/extractors/licensing_test.go:159:13: string `DOCUMENT` has 7 occurrences, make it a constant (goconst)
	s.Spdxid = "DOCUMENT"
	           ^
pkg/scorer/v2/extractors/licensing_test.go:160:16: string `https://example.com/ns` has 4 occurrences, make it a constant (goconst)
	s.Namespace = "https://example.com/ns"
	              ^
pkg/scorer/v2/extractors/vulnerability_test.go:68:24: string `2025-01-01T00:00:00Z` has 5 occurrences, make it a constant (goconst)
	s.CreationTimestamp = "2025-01-01T00:00:00Z"
	                      ^
pkg/scorer/v2/profiles/common.go:603:50: string `spdx` has 12 occurrences, make it a constant (goconst)
	if strings.ToLower(doc.Spec().GetSpecType()) == "spdx" {
	                                                ^
pkg/scorer/v2/profiles/common_test.go:142:14: string `1.6` has 3 occurrences, make it a constant (goconst)
	s.Version = "1.6"
	            ^
pkg/scorer/v2/profiles/common_test.go:144:13: string `json` has 8 occurrences, make it a constant (goconst)
	s.Format = "json"
	           ^
pkg/scorer/v2/profiles/common_test.go:154:14: string `SPDX-2.3` has 4 occurrences, make it a constant (goconst)
	s.Version = "SPDX-2.3"
	            ^
pkg/scorer/v2/profiles/ntia_2025.go:32:12: string `complete` has 15 occurrences, make it a constant (goconst)
				desc = "complete"
				       ^
pkg/scorer/v2/profiles/ntia_2025.go:51:13: string `cyclonedx` has 8 occurrences, make it a constant (goconst)
	if spec == "cyclonedx" {
	           ^
pkg/scorer/v2/profiles/ntia_2025.go:143:11: string `add to 1 component` has 3 occurrences, make it a constant (goconst)
			desc = "add to 1 component"
			       ^
cmd/list.go:189:5: sloppyLen: len(uCmd.path) <= 0 can be len(uCmd.path) == 0 (gocritic)
	if len(uCmd.path) <= 0 {
	   ^
cmd/score.go:103:6: sloppyLen: len(args) <= 0 can be len(args) == 0 (gocritic)
		if len(args) <= 0 {
		   ^
cmd/score.go:104:27: sloppyLen: len(inDirPath) <= 0 can be len(inDirPath) == 0 (gocritic)
			if len(inFile) <= 0 && len(inDirPath) <= 0 {
			                       ^
cmd/score.go:221:5: sloppyLen: len(args) <= 0 can be len(args) == 0 (gocritic)
	if len(args) <= 0 {
	   ^
pkg/compliance/bsi_v2_report.go:62:4: assignOp: replace `sectionID = sectionID + "*"` with `sectionID += "*"` (gocritic)
			sectionID = sectionID + "*"
			^
pkg/compliance/ntia.go:385:4: assignOp: replace `result = result + x` with `result += x` (gocritic)
			result = result + x
			^
pkg/compliance/ntia_report.go:178:4: assignOp: replace `sectionID = sectionID + "*"` with `sectionID += "*"` (gocritic)
			sectionID = sectionID + "*"
			^
pkg/compliance/oct.go:403:3: assignOp: replace `result = result + x` with `result += x` (gocritic)
		result = result + x
		^
pkg/compliance/oct_report.go:188:4: assignOp: replace `sectionID = sectionID + "*"` with `sectionID += "*"` (gocritic)
			sectionID = sectionID + "*"
			^
pkg/engine/compliance.go:33:5: sloppyLen: len(ep.Path) <= 0 can be len(ep.Path) == 0 (gocritic)
	if len(ep.Path) <= 0 {
	   ^
pkg/engine/dtrack.go:91:5: exitAfterDefer: log.Fatalf will exit, and `defer os.Remove(f.Name())` will not run (gocritic)
				log.Fatalf("Failed to write string: %v", err)
				^
pkg/engine/score.go:83:5: sloppyLen: len(ep.Path) <= 0 can be len(ep.Path) == 0 (gocritic)
	if len(ep.Path) <= 0 {
	   ^
pkg/engine/score.go:370:8: sloppyLen: len(category) <= 0 can be len(category) == 0 (gocritic)
				if len(category) <= 0 {
				   ^
pkg/engine/score.go:381:8: sloppyLen: len(cat) <= 0 can be len(cat) == 0 (gocritic)
				if len(cat) <= 0 {
				   ^
pkg/engine/score.go:385:9: sloppyLen: len(feat) <= 0 can be len(feat) == 0 (gocritic)
					if len(feat) <= 0 {
					   ^
pkg/engine/score.go:399:7: sloppyLen: len(feature) <= 0 can be len(feature) == 0 (gocritic)
			if len(feature) <= 0 {
			   ^
pkg/engine/score.go:413:4: exitAfterDefer: log.Fatalf will exit, and `defer f.Close()` will not run (gocritic)
			log.Fatalf("failed to read config file %s : %s", ep.ConfigPath, er)
			^
pkg/engine/score.go:416:6: sloppyLen: len(filters) <= 0 can be len(filters) == 0 (gocritic)
		if len(filters) <= 0 {
		   ^
pkg/engine/share.go:34:5: sloppyLen: len(ep.Path) <= 0 can be len(ep.Path) == 0 (gocritic)
	if len(ep.Path) <= 0 {
	   ^
pkg/list/compeval.go:76:15: appendAssign: append result not assigned to the same slice (gocritic)
		combined := append(allPurls, allCPEs...)
		            ^
pkg/list/report.go:74:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if r.Format == "basic" {
	^
pkg/list/report.go:155:5: dupBranchBody: both branches in if statement have same body (gocritic)
				if result.DocumentProperty.Present {
				^
pkg/reporter/report.go:68:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if r.Format == "basic" {
	^
pkg/reporter/v2/detailed.go:45:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if r.Comprehensive != nil && r.Profiles != nil {
		^
pkg/sbom/sbom.go:110:3: exitAfterDefer: log.Fatalf will exit, and `defer func(){...}(...)` will not run (gocritic)
		log.Fatalf("Failed to seek: %v", err)
		^
pkg/scorer/v2/extractors/completeness.go:33:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.HasComponentDependencies(c)
}` with `commonV2.HasComponentDependencies` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/extractors/integrity.go:84:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if withWeakOnly == 0 {
	^
pkg/scorer/v2/extractors/licensing.go:34:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyConcluded(c)
}` with `commonV2.ComponentHasAnyConcluded` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/extractors/licensing.go:48:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ValidationCheckConcludedLicenses(c)
}` with `commonV2.ValidationCheckConcludedLicenses` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/extractors/licensing.go:62:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyDeclared(c)
}` with `commonV2.ComponentHasAnyDeclared` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/extractors/licensing.go:103:47: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyConcluded(c)
}` with `commonV2.ComponentHasAnyConcluded` (gocritic)
	componentsWithConcluded := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                                             ^
pkg/scorer/v2/extractors/licensing.go:117:38: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyDeprecated(c)
}` with `commonV2.ComponentHasAnyDeprecated` (gocritic)
	withDeprecated := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                                    ^
pkg/scorer/v2/extractors/licensing.go:125:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if withDeprecated == 0 {
	^
pkg/scorer/v2/extractors/licensing.go:150:47: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyConcluded(c)
}` with `commonV2.ComponentHasAnyConcluded` (gocritic)
	componentsWithConcluded := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                                             ^
pkg/scorer/v2/extractors/licensing.go:164:39: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyRestrictive(c)
}` with `commonV2.ComponentHasAnyRestrictive` (gocritic)
	withRestrictive := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                                     ^
pkg/scorer/v2/extractors/licensing.go:172:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if withRestrictive == 0 {
	^
pkg/scorer/v2/extractors/licensing_test.go:74:4: ifElseChain: rewrite if-else to switch statement (gocritic)
			if it.licenseID != "" {
			^
pkg/scorer/v2/extractors/vulnerability.go:32:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.CompHasAnyPURLs(c)
}` with `commonV2.CompHasAnyPURLs` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/extractors/vulnerability.go:46:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.CompHasAnyCPEs(c)
}` with `commonV2.CompHasAnyCPEs` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:293:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyConcluded(c)
}` with `commonV2.ComponentHasAnyConcluded` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:307:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyConcluded(c)
}` with `commonV2.ComponentHasAnyConcluded` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:322:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.HasSHA1Plus(c)
}` with `commonV2.HasSHA1Plus` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:424:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.HasComponentDependencies(c)
}` with `commonV2.HasComponentDependencies` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:437:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return checkUniqueID(c)
}` with `checkUniqueID` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:450:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.CompHasAnyPURLs(c)
}` with `commonV2.CompHasAnyPURLs` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:463:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.CompHasAnyCPEs(c)
}` with `commonV2.CompHasAnyCPEs` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:489:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyDeprecated(c)
}` with `commonV2.ComponentHasAnyDeprecated` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:511:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyRestrictive(c)
}` with `commonV2.ComponentHasAnyRestrictive` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/common.go:547:28: unlambda: replace `func(c sbom.GetComponent) bool {
	return commonV2.ComponentHasAnyDeclared(c)
}` with `commonV2.ComponentHasAnyDeclared` (gocritic)
	have := lo.CountBy(comps, func(c sbom.GetComponent) bool {
	                          ^
pkg/scorer/v2/profiles/ntia.go:88:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if have == total {
	^
pkg/scorer/v2/profiles/ntia.go:139:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if have == total {
	^
pkg/scorer/v2/profiles/ntia.go:175:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if have == total {
	^
pkg/scorer/v2/profiles/ntia_2025.go:136:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if componentsWithHash == 0 {
	^
pkg/scorer/v2/profiles/ntia_2025.go:198:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if componentsWithLicense == 0 {
	^
pkg/scorer/v2/profiles/ntia_2025.go:267:2: ifElseChain: rewrite if-else to switch statement (gocritic)
	if componentsWithId == 0 {
	^
pkg/scorer/v2/profiles/profile.go:75:3: ifElseChain: rewrite if-else to switch statement (gocritic)
		if pFeatScore.Ignore {
		^
pkg/compliance/bsiV2.go:111:22: G304: Potential file inclusion via variable (gosec)
		pubKeyData, err := os.ReadFile(pubKey)
		                   ^
pkg/compliance/common/common.go:529:14: G304: Potential file inclusion via variable (gosec)
	sig, err := os.ReadFile(signaturePath)
	            ^
pkg/compliance/common/common.go:544:19: G304: Potential file inclusion via variable (gosec)
	sbomData, err := os.ReadFile(sbomPath)
	                 ^
pkg/compliance/common/sig.go:56:15: G304: Potential file inclusion via variable (gosec)
	data, err := os.ReadFile(sbomFile)
	             ^
pkg/compliance/common/sig.go:201:17: G304: Potential file inclusion via variable (gosec)
	content, err = os.ReadFile(path)
	               ^
pkg/engine/compliance.go:139:13: G304: Potential file inclusion via variable (gosec)
		f, err := os.Open(path)
		          ^
pkg/engine/score.go:348:13: G304: Potential file inclusion via variable (gosec)
		f, err := os.Open(path)
		          ^
pkg/list/list.go:147:12: G304: Potential file inclusion via variable (gosec)
	f, err := os.Open(filePath)
	          ^
pkg/policy/policy.go:55:22: G304: Potential file inclusion via variable (gosec)
	policyBytes, err := os.ReadFile(path)
	                    ^
pkg/scorer/bsi.go:340:22: G304: Potential file inclusion via variable (gosec)
		pubKeyData, err := os.ReadFile(pubKey)
		                   ^
pkg/scorer/config.go:148:12: G304: Potential file inclusion via variable (gosec)
	f, err := os.Open(path)
	          ^
pkg/scorer/v2/extractors/integrity.go:135:22: G304: Potential file inclusion via variable (gosec)
	pubKeyBytes, err := os.ReadFile(pubKeyPath)
	                    ^
pkg/scorer/v2/profiles/common.go:570:22: G304: Potential file inclusion via variable (gosec)
	pubKeyBytes, err := os.ReadFile(pubKeyPath)
	                    ^
pkg/scorer/v2/registry/compr.go:87:12: G304: Potential file inclusion via variable (gosec)
	b, err := os.ReadFile(path)
	          ^
pkg/scorer/v2/registry/profile.go:92:12: G304: Potential file inclusion via variable (gosec)
	b, err := os.ReadFile(path)
	          ^
pkg/scorer/v2/registry/registry.go:347:12: G304: Potential file inclusion via variable (gosec)
	b, err := os.ReadFile(path)
	          ^
pkg/scorer/v2/score/resolver.go:77:15: G304: Potential file inclusion via variable (gosec)
	file, err := os.Open(filePath)
	             ^
pkg/scorer/v2/score/score.go:111:12: G304: Potential file inclusion via variable (gosec)
		f, err = os.Open(path)
		         ^
pkg/scorer/v2/score/validate_test.go:63:12: G306: Expect WriteFile permissions to be 0600 or less (gosec)
	if err := os.WriteFile(f1, []byte("hello"), 0o644); err != nil {
	          ^
pkg/scorer/v2/score/validate_test.go:68:12: G306: Expect WriteFile permissions to be 0600 or less (gosec)
	if err := os.WriteFile(f2, []byte("hi"), 0o644); err != nil {
	          ^
pkg/scorer/v2/score/validate_test.go:101:12: G306: Expect WriteFile permissions to be 0600 or less (gosec)
	if err := os.WriteFile(f1, []byte("hello"), 0o644); err != nil {
	          ^
pkg/scorer/v2/score/validate_test.go:107:12: G301: Expect directory permissions to be 0750 or less (gosec)
	if err := os.Mkdir(sub, 0o755); err != nil {
	          ^
pkg/scorer/v2/score/validate_test.go:110:12: G306: Expect WriteFile permissions to be 0600 or less (gosec)
	if err := os.WriteFile(filepath.Join(sub, "nested.json"), []byte("x"), 0o644); err != nil {
	          ^
pkg/scorer/v2/score/validate_test.go:116:12: G306: Expect WriteFile permissions to be 0600 or less (gosec)
	if err := os.WriteFile(f2, []byte("hi"), 0o644); err != nil {
	          ^
pkg/scorer/tools.go:16:1: buildtag: +build line is no longer needed (govet)
// +build tools
^
pkg/policy/evaluator.go:64:7: `retreive` is a misspelling of `retrieve` (misspell)
			// retreive the actual values from component for that respective field
			   ^
pkg/policy/result.go:34:67: `decalred` is a misspelling of `declared` (misspell)
	DeclaredValues string   `json:"declared_values"`          // the decalred values
	                                                                 ^
pkg/scorer/v2/formulae/farmulas.go:219:21: `qaulity` is a misspelling of `quality` (misspell)
		// Skip component qaulity informational category
		                  ^
pkg/scorer/v2/profiles/common.go:392:43: `determinsitic` is a misspelling of `deterministic` (misspell)
// `PackageVerificationCode` for SPDX, no determinsitic field in CDX
                                          ^
pkg/engine/share.go:41:4: error is not nil (line 39) but it returns nil (nilerr)
			return nil
			^
pkg/compliance/common/sig.go:64:2: directive `// nolint` should be written without leading space as `//nolint` (nolintlint)
	// nolint
	^
pkg/compliance/common/sig.go:67:2: directive `// nolint` should be written without leading space as `//nolint` (nolintlint)
	// nolint
	^
pkg/compliance/db/db.go:87:1: directive `// nolint` should be written without leading space as `//nolint` (nolintlint)
// nolint
^
pkg/compliance/fsct/fsct_report.go:31:1: directive `// nolint` should be written without leading space as `//nolint` (nolintlint)
// nolint
^
pkg/compliance/ntia.go:35:1: directive `// nolint` should be written without leading space as `//nolint` (nolintlint)
// nolint
^
pkg/sbom/cdx.go:554:3: directive `//nolint:gosec` is unused for linter "gosec" (nolintlint)
		//nolint:gosec
		^
pkg/sbom/cdx.go:559:3: directive `//nolint:gosec` is unused for linter "gosec" (nolintlint)
		//nolint:gosec
		^
pkg/scorer/scorer.go:122:43: directive `//nolint:gosec` is unused for linter "gosec" (nolintlint)
			scores.addScore(c.evaluate(s.doc, &c)) //nolint:gosec
			                                       ^
pkg/scorer/scorer.go:135:43: directive `//nolint:gosec` is unused for linter "gosec" (nolintlint)
			scores.addScore(c.evaluate(s.doc, &c)) //nolint:gosec
			                                       ^
pkg/scorer/scorer.go:146:42: directive `//nolint:gosec` is unused for linter "gosec" (nolintlint)
		scores.addScore(c.evaluate(s.doc, &c)) //nolint:gosec
		                                       ^
cmd/score.go:206:2: Consider pre-allocating `validPaths` (prealloc)
	var validPaths []string
	^
pkg/compliance/bsi_score.go:128:2: Consider pre-allocating `results` (prealloc)
	var results []bsiScoreResult
	^
pkg/compliance/common/common.go:266:2: Consider pre-allocating `result` (prealloc)
	var result []string
	^
pkg/compliance/common/common.go:351:2: Consider pre-allocating `allDepByName` (prealloc)
	var allDepByName []string
	^
pkg/compliance/fsct/fsct.go:144:2: Consider pre-allocating `allDepByName` (prealloc)
	var allDepByName []string
	^
pkg/compliance/fsct/fsct_score.go:128:2: Consider pre-allocating `results` (prealloc)
	var results []fsctScoreResult
	^
pkg/compliance/ntia_score.go:96:2: Consider pre-allocating `results` (prealloc)
	var results []ntiaScoreResult
	^
pkg/compliance/oct_score.go:96:2: Consider pre-allocating `results` (prealloc)
	var results []octScoreResult
	^
pkg/list/compeval.go:64:2: Consider pre-allocating `allPurls` (prealloc)
	var allPurls []string
	^
pkg/list/compeval.go:69:2: Consider pre-allocating `allCPEs` (prealloc)
	var allCPEs []string
	^
pkg/list/compeval.go:107:2: Consider pre-allocating `all` (prealloc)
	var all []string
	^
pkg/list/compeval.go:120:2: Consider pre-allocating `all` (prealloc)
	var all []string
	^
pkg/list/doceval.go:356:2: Consider pre-allocating `all` (prealloc)
	var all []string
	^
pkg/list/list.go:132:2: Consider pre-allocating `results` (prealloc)
	var results []*Result
	^
pkg/policy/engine.go:51:2: Consider pre-allocating `policyResults` (prealloc)
	var policyResults []PolicyResult
	^
pkg/reporter/v2/detailed.go:226:2: Consider pre-allocating `rows` (prealloc)
	var rows [][]string
	^
pkg/scorer/v2/extractors/completeness_test.go:61:2: Consider pre-allocating `comps` (prealloc)
	var comps []sbom.GetComponent
	^
pkg/scorer/v2/extractors/completeness_test.go:62:2: Consider pre-allocating `deps` (prealloc)
	var deps []sbom.GetRelation
	^
pkg/scorer/v2/extractors/identification_test.go:86:2: Consider pre-allocating `comps` (prealloc)
	var comps []sbom.GetComponent
	^
pkg/scorer/v2/extractors/identification_test.go:115:2: Consider pre-allocating `comps` (prealloc)
	var comps []sbom.GetComponent
	^
pkg/scorer/v2/extractors/licensing_test.go:65:2: Consider pre-allocating `cs` (prealloc)
	var cs []sbom.GetComponent
	^
pkg/scorer/v2/extractors/licensing_test.go:124:2: Consider pre-allocating `cs` (prealloc)
	var cs []sbom.GetComponent
	^
pkg/scorer/v2/extractors/licensing_test.go:169:2: Consider pre-allocating `cs` (prealloc)
	var cs []sbom.GetComponent
	^
pkg/scorer/v2/extractors/provenance_test.go:52:2: Consider pre-allocating `tools` (prealloc)
	var tools []sbom.GetTool
	^
pkg/scorer/v2/extractors/provenance_test.go:58:2: Consider pre-allocating `authors` (prealloc)
	var authors []sbom.GetAuthor
	^
pkg/scorer/v2/extractors/provenance_test.go:82:2: Consider pre-allocating `tools` (prealloc)
	var tools []sbom.GetTool
	^
pkg/scorer/v2/extractors/vulnerability_test.go:45:2: Consider pre-allocating `cs` (prealloc)
	var cs []sbom.GetComponent
	^
pkg/scorer/v2/extractors/vulnerability_test.go:70:2: Consider pre-allocating `cs` (prealloc)
	var cs []sbom.GetComponent
	^
pkg/scorer/v2/profiles/common_test.go:264:2: Consider pre-allocating `aths` (prealloc)
	var aths []sbom.GetAuthor
	^
pkg/scorer/v2/profiles/common_test.go:281:2: Consider pre-allocating `aths` (prealloc)
	var aths []sbom.GetAuthor
	^
pkg/scorer/v2/profiles/common_test.go:349:2: Consider pre-allocating `cs` (prealloc)
	var cs []sbom.GetComponent
	^
pkg/scorer/v2/profiles/common_test.go:376:2: Consider pre-allocating `cs` (prealloc)
	var cs []sbom.GetComponent
	^
pkg/scorer/v2/registry/compr.go:96:2: Consider pre-allocating `cat` (prealloc)
	var cat []catalog.ComprCatSpec
	^
pkg/scorer/v2/registry/profile.go:101:2: Consider pre-allocating `pro` (prealloc)
	var pro []catalog.ProfSpec
	^
pkg/scorer/v2/registry/profile.go:139:2: Consider pre-allocating `profSpec` (prealloc)
	var profSpec []catalog.ProfFeatSpec
	^
cmd/compliance.go:1:1: package-comments: package comment should be of the form "Package cmd ..." (revive)
// Copyright 2025 Interlynk.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
cmd/generate.go:1:1: package-comments: package comment should be of the form "Package cmd ..." (revive)
// Copyright 2025 Interlynk.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
cmd/root.go:1:1: package-comments: package comment should be of the form "Package cmd ..." (revive)
// Copyright 2025 Interlynk.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
cmd/score.go:1:1: package-comments: package comment should be of the form "Package cmd ..." (revive)
// Copyright 2025 Interlynk.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
cmd/share.go:1:1: package-comments: package comment should be of the form "Package cmd ..." (revive)
// Copyright 2025 Interlynk.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
main.go:15:1: package-comments: should have a package comment (revive)
package main
^
pkg/compliance/bsi.go:15:1: package-comments: should have a package comment (revive)
package compliance
^
pkg/compliance/bsi_report.go:68:6: exported: exported type Summary should have comment or be unexported (revive)
type Summary struct {
     ^
pkg/compliance/common/common.go:15:1: package-comments: should have a package comment (revive)
package common
^
pkg/compliance/common/common.go:40:1: exported: exported function CheckTools should have comment or be unexported (revive)
func CheckTools(tools []sbom.GetTool) (string, bool) {
^
pkg/compliance/common/common.go:60:1: exported: exported function CheckAuthors should have comment or be unexported (revive)
func CheckAuthors(authors []sbom.GetAuthor) (string, bool) {
^
pkg/compliance/common/common.go:101:1: exported: exported function CheckSupplier should have comment or be unexported (revive)
func CheckSupplier(supplier sbom.GetSupplier) (string, bool) {
^
pkg/compliance/common/common.go:148:1: exported: exported function CheckManufacturer should have comment or be unexported (revive)
func CheckManufacturer(manufacturer sbom.GetManufacturer) (string, bool) {
^
pkg/compliance/common/common.go:167:1: exported: exported function CheckTimestamp should have comment or be unexported (revive)
func CheckTimestamp(timestamp string) (string, bool) {
^
pkg/compliance/common/common.go:175:1: exported: exported function CheckPurls should have comment or be unexported (revive)
func CheckPurls(purls []purl.PURL) (string, bool) {
^
pkg/compliance/common/common.go:188:1: exported: exported function CheckCpes should have comment or be unexported (revive)
func CheckCpes(cpes []cpe.CPE) (string, bool) {
^
pkg/compliance/common/common.go:201:1: exported: exported function CheckOmnibor should have comment or be unexported (revive)
func CheckOmnibor(omni []omniborid.OMNIBORID) (string, bool) {
^
pkg/compliance/common/common.go:214:1: exported: exported function CheckSwhid should have comment or be unexported (revive)
func CheckSwhid(swhid []swhid.SWHID) (string, bool) {
^
pkg/compliance/common/common.go:227:1: exported: exported function CheckSwid should have comment or be unexported (revive)
func CheckSwid(swid []swid.SWID) (string, bool) {
^
pkg/compliance/common/common.go:241:1: exported: exported function CheckHash should have comment or be unexported (revive)
func CheckHash(checksums []sbom.GetChecksum) (string, bool, bool) {
^
pkg/compliance/common/common.go:275:1: exported: exported function CheckCopyright should have comment or be unexported (revive)
func CheckCopyright(cp string) (string, bool) {
^
pkg/compliance/common/common.go:358:1: exported: exported function GetID should have comment or be unexported (revive)
func GetID(componentID string) string {
^
pkg/compliance/common/common.go:362:1: exported: exported function UniqueElementID should have comment or be unexported (revive)
func UniqueElementID(component sbom.GetComponent) string {
^
pkg/compliance/common/common.go:379:1: exported: exported function IsComponentPartOfPrimaryDependency should have comment or be unexported (revive)
func IsComponentPartOfPrimaryDependency(primaryCompDeps []string, comp string) bool {
^
pkg/compliance/common/common.go:388:1: exported: exported function SetHeaderColor should have comment or be unexported (revive)
func SetHeaderColor(table *tablewriter.Table, header int) {
^
pkg/compliance/common/common.go:399:1: exported: exported function ColorTable should have comment or be unexported (revive)
func ColorTable(table *tablewriter.Table, elementID, id string, elementResult string, dataFields string, score float64, columnWidth int) *tablewriter.Table {
^
pkg/compliance/common/common.go:450:1: exported: exported function GetScoreColor should have comment or be unexported (revive)
func GetScoreColor(score float64) tablewriter.Colors {
^
pkg/compliance/common/common.go:459:1: exported: exported function WrapText should have comment or be unexported (revive)
func WrapText(input string, maxWidth int) string {
^
pkg/compliance/common/common.go:473:1: exported: comment on exported function WrapLongTextIntoMulti should be of the form "WrapLongTextIntoMulti ..." (revive)
// convert long text into multiple lines
^
pkg/compliance/common/common.go:484:1: exported: exported function AreLicensesValid should have comment or be unexported (revive)
func AreLicensesValid(licenses []licenses.License) bool {
^
pkg/compliance/common/common.go:506:1: exported: exported function VerifySignature should have comment or be unexported (revive)
func VerifySignature(pubKeyData []byte, sbomPath, signaturePath string) (bool, error) {
^
pkg/compliance/common/common.go:543:1: exported: exported function HashSBOM should have comment or be unexported (revive)
func HashSBOM(sbomPath string) ([]byte, error) {
^
pkg/compliance/common/common.go:552:1: exported: exported function RemoveFileIfExists should have comment or be unexported (revive)
func RemoveFileIfExists(filePath string) {
^
pkg/compliance/common/sig.go:15:9: var-naming: avoid meaningless package names (revive)
package common
        ^
pkg/compliance/common/sig.go:34:6: exported: exported type SBOM should have comment or be unexported (revive)
type SBOM struct {
     ^
pkg/compliance/common/sig.go:39:6: exported: exported type Signature should have comment or be unexported (revive)
type Signature struct {
     ^
pkg/compliance/common/sig.go:45:6: exported: exported type PublicKey should have comment or be unexported (revive)
type PublicKey struct {
     ^
pkg/compliance/common/sig.go:51:1: exported: exported function RetrieveSignatureFromSBOM should have comment or be unexported (revive)
func RetrieveSignatureFromSBOM(ctx context.Context, sbomFile string) (string, string, string, error) {
^
pkg/compliance/common/sig.go:134:1: exported: exported function DecodeBase64URLEncodingToInt should have comment or be unexported (revive)
func DecodeBase64URLEncodingToInt(input string) int {
^
pkg/compliance/common/sig.go:149:1: exported: exported function DecodeBigInt should have comment or be unexported (revive)
func DecodeBigInt(input []byte) *big.Int {
^
pkg/compliance/common/sig.go:155:1: exported: exported function PublicKeyToPEM should have comment or be unexported (revive)
func PublicKeyToPEM(pub *rsa.PublicKey) []byte {
^
pkg/compliance/common/sig.go:168:1: exported: exported function GetSignatureBundle should have comment or be unexported (revive)
func GetSignatureBundle(ctx context.Context, sbomFile, signature, publicKey string) (string, string, string, error) {
^
pkg/compliance/db/db.go:15:1: package-comments: should have a package comment (revive)
package db
^
pkg/compliance/db/db.go:21:6: exported: exported type DB should have comment or be unexported (revive)
type DB struct {
     ^
pkg/compliance/db/db.go:28:1: exported: comment on exported function NewDB should be of the form "NewDB ..." to match its exported status, not "newDB ..." (revive)
// newDB initializes and returns a new database instance.
^
pkg/compliance/db/db.go:38:1: exported: comment on exported method DB.AddRecord should be of the form "AddRecord ..." to match its exported status, not "addRecord ..." (revive)
// addRecord adds a single record to the database
^
pkg/compliance/db/db.go:55:1: exported: comment on exported method DB.AddRecords should be of the form "AddRecords ..." to match its exported status, not "addRecords ..." (revive)
// addRecords adds multiple records to the database
^
pkg/compliance/db/db.go:62:1: exported: comment on exported method DB.GetRecords should be of the form "GetRecords ..." to match its exported status, not "getRecords ..." (revive)
// getRecords retrieves records by the given "check_key"
^
pkg/compliance/db/db.go:67:1: exported: comment on exported method DB.GetAllIDs should be of the form "GetAllIDs ..." to match its exported status, not "getAllIDs ..." (revive)
// getAllIDs retrieves all unique ids in the database
^
pkg/compliance/db/db.go:76:1: exported: comment on exported method DB.GetRecordsByID should be of the form "GetRecordsByID ..." to match its exported status, not "getRecordsByID ..." (revive)
// getRecordsByID retrieves records by the given "id"
^
pkg/compliance/db/db.go:81:1: exported: comment on exported method DB.GetRecordsByKeyID should be of the form "GetRecordsByKeyID ..." to match its exported status, not "getRecordsByKeyID ..." (revive)
// getRecordsByKeyID retrieves records by the given "check_key" and "id"
^
pkg/compliance/db/record.go:17:6: exported: exported type Record should have comment or be unexported (revive)
type Record struct {
     ^
pkg/compliance/db/record.go:26:1: exported: exported function NewRecord should have comment or be unexported (revive)
func NewRecord() *Record {
^
pkg/compliance/db/record.go:30:1: exported: exported function NewRecordStmt should have comment or be unexported (revive)
func NewRecordStmt(key int, id, value string, score float64, maturity string) *Record {
^
pkg/compliance/db/record.go:41:1: exported: exported function NewRecordStmtOptional should have comment or be unexported (revive)
func NewRecordStmtOptional(key int, id, value string, score float64) *Record {
^
pkg/compliance/fsct/fsct.go:15:1: package-comments: should have a package comment (revive)
package fsct
^
pkg/compliance/fsct/fsct.go:28:1: exported: exported function Result should have comment or be unexported (revive)
func Result(ctx context.Context, doc sbom.Document, fileName string, outFormat string, coloredOutput bool) {
^
pkg/compliance/fsct/fsct.go:56:1: exported: exported function SbomPrimaryComponent should have comment or be unexported (revive)
func SbomPrimaryComponent(doc sbom.Document) *db.Record {
^
pkg/compliance/fsct/fsct.go:70:1: exported: exported function SbomType should have comment or be unexported (revive)
func SbomType(doc sbom.Document) *db.Record {
^
pkg/compliance/fsct/fsct.go:85:1: exported: exported function SbomTimestamp should have comment or be unexported (revive)
func SbomTimestamp(doc sbom.Document) *db.Record {
^
pkg/compliance/fsct/fsct.go:97:1: exported: exported function SbomAuthor should have comment or be unexported (revive)
func SbomAuthor(doc sbom.Document) *db.Record {
^
pkg/compliance/fsct/fsct.go:135:2: exported: exported var CompIDWithName should have comment or be unexported (revive)
	CompIDWithName                          = make(map[string]string)
	^
pkg/compliance/fsct/fsct.go:151:1: exported: exported function Components should have comment or be unexported (revive)
func Components(doc sbom.Document) []*db.Record {
^
pkg/compliance/fsct/fsct_report.go:83:6: exported: exported type Summary should have comment or be unexported (revive)
type Summary struct {
     ^
pkg/compliance/ntia.go:226:2: exported: exported var GetAllPrimaryDepenciesByName should have comment or be unexported (revive)
	GetAllPrimaryDepenciesByName = []string{}
	^
pkg/cpe/cpe.go:1:1: package-comments: package comment should be of the form "Package cpe ..." (revive)
// Copyright 2025 Interlynk.io
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
pkg/cpe/cpe.go:20:6: exported: exported type CPE should have comment or be unexported (revive)
type CPE string
     ^
pkg/cpe/cpe.go:25:1: exported: exported method CPE.Valid should have comment or be unexported (revive)
func (cpe CPE) Valid() bool {
^
pkg/cpe/cpe.go:29:1: exported: exported function NewCPE should have comment or be unexported (revive)
func NewCPE(cpe string) CPE {
^
pkg/engine/compliance.go:15:1: package-comments: should have a package comment (revive)
package engine
^
pkg/engine/compliance.go:29:1: exported: exported function ComplianceRun should have comment or be unexported (revive)
func ComplianceRun(ctx context.Context, ep *Params) error {
^
pkg/engine/dtrack.go:35:6: exported: exported type DtParams should have comment or be unexported (revive)
type DtParams struct {
     ^
pkg/engine/list.go:38:1: exported: exported function ListRun should have comment or be unexported (revive)
func ListRun(ctx context.Context, ep *Params) error {
^
pkg/engine/score.go:41:6: exported: exported type Params should have comment or be unexported (revive)
type Params struct {
     ^
pkg/engine/score.go:78:1: exported: exported function Run should have comment or be unexported (revive)
func Run(ctx context.Context, ep *Params) error {
^
pkg/engine/score.go:151:1: exported: exported function IsURL should have comment or be unexported (revive)
func IsURL(in string) bool {
^
pkg/engine/score.go:155:1: exported: exported function IsGit should have comment or be unexported (revive)
func IsGit(in string) bool {
^
pkg/engine/score.go:159:1: exported: exported function ProcessURL should have comment or be unexported (revive)
func ProcessURL(url string, file afero.File) (afero.File, error) {
^
pkg/engine/share.go:30:1: exported: exported function ShareRun should have comment or be unexported (revive)
func ShareRun(ctx context.Context, ep *Params) error {
^
pkg/licenses/embed_licenses.go:15:1: package-comments: should have a package comment (revive)
package licenses
^
pkg/licenses/license.go:24:6: exported: exported type License should have comment or be unexported (revive)
type License interface {
     ^
pkg/licenses/license.go:99:1: exported: exported function LookupSpdxLicense should have comment or be unexported (revive)
func LookupSpdxLicense(licenseKey string) (License, error) {
^
pkg/licenses/license.go:124:1: exported: exported function LookupAboutCodeLicense should have comment or be unexported (revive)
func LookupAboutCodeLicense(licenseKey string) (License, error) {
^
pkg/licenses/license.go:146:1: exported: exported function LookupExpression should have comment or be unexported (revive)
func LookupExpression(expression string, customLicenses []License) []License {
^
pkg/licenses/license.go:202:1: exported: exported function CreateCustomLicense should have comment or be unexported (revive)
func CreateCustomLicense(id, name string) License {
^
pkg/list/compeval.go:15:1: package-comments: should have a package comment (revive)
package list
^
pkg/list/compeval.go:274:37: unused-parameter: parameter 'doc' seems to be unused, consider removing or renaming it as _ (revive)
func evaluateCompWithPrimaryPurpose(doc sbom.Document, comp sbom.GetComponent) (bool, string, error) {
                                    ^
pkg/list/report.go:31:6: exported: exported type OptionList should have comment or be unexported (revive)
type OptionList func(r *Report)
     ^
pkg/list/report.go:33:1: exported: exported function NewListReport should have comment or be unexported (revive)
func NewListReport(ctx context.Context, results []*Result, opts ...OptionList) *Report {
^
pkg/list/report.go:45:1: exported: exported function WithFormat should have comment or be unexported (revive)
func WithFormat(c string) OptionList {
^
pkg/list/report.go:51:1: exported: exported function WithColor should have comment or be unexported (revive)
func WithColor(c bool) OptionList {
^
pkg/list/report.go:57:1: exported: exported function WithValues should have comment or be unexported (revive)
func WithValues(s bool) OptionList {
^
pkg/list/report.go:63:1: exported: comment on exported type Report should be of the form "Report ..." (with optional leading article) (revive)
// listReport holds the state for reporting the list command results
^
pkg/list/types.go:17:6: exported: exported type Result should have comment or be unexported (revive)
type Result struct {
     ^
pkg/list/types.go:27:6: exported: exported type ComponentResult should have comment or be unexported (revive)
type ComponentResult struct {
     ^
pkg/list/types.go:33:6: exported: exported type DocumentResult should have comment or be unexported (revive)
type DocumentResult struct {
     ^
pkg/list/types.go:39:6: exported: exported type Params should have comment or be unexported (revive)
type Params struct {
     ^
pkg/logger/log.go:15:1: package-comments: should have a package comment (revive)
package logger
^
pkg/logger/log.go:28:1: exported: exported function InitProdLogger should have comment or be unexported (revive)
func InitProdLogger() {
^
pkg/logger/log.go:46:1: exported: exported function InitDebugLogger should have comment or be unexported (revive)
func InitDebugLogger() {
^
pkg/logger/log.go:64:1: exported: exported function WithLogger should have comment or be unexported (revive)
func WithLogger(ctx context.Context) context.Context {
^
pkg/logger/log.go:68:1: exported: exported function WithLoggerAndCancel should have comment or be unexported (revive)
func WithLoggerAndCancel(ctx context.Context) (context.Context, context.CancelFunc) {
^
pkg/logger/log.go:72:1: exported: exported function FromContext should have comment or be unexported (revive)
func FromContext(ctx context.Context) *zap.SugaredLogger {
^
pkg/omniborid/omniborid.go:19:6: exported: exported type OMNIBORID should have comment or be unexported (revive)
type OMNIBORID string
     ^
pkg/omniborid/omniborid.go:23:1: exported: exported method OMNIBORID.Valid should have comment or be unexported (revive)
func (omni OMNIBORID) Valid() bool {
^
pkg/omniborid/omniborid.go:27:1: exported: exported function NewOmni should have comment or be unexported (revive)
func NewOmni(omni string) OMNIBORID {
^
pkg/policy/engine.go:15:1: package-comments: should have a package comment (revive)
package policy
^
pkg/policy/engine.go:27:1: exported: exported function Engine should have comment or be unexported (revive)
func Engine(ctx context.Context, policyConfig *Params, policies []Policy) error {
^
pkg/policy/extractor.go:33:1: exported: exported function NewExtractor should have comment or be unexported (revive)
func NewExtractor(doc sbom.Document) *Extractor {
^
pkg/policy/extractor.go:270:1: exported: comment on exported method Extractor.RetrieveValues should be of the form "RetrieveValues ..." (revive)
// Values returns a slice of string values for the given field on the
^
pkg/policy/extractor.go:276:1: receiver-naming: receiver name e should be consistent with previous receiver name extractor for Extractor (revive)
func (e *Extractor) RetrieveValues(comp sbom.GetComponent, field string) []string {
	if e == nil {
		return nil
	}
	f := strings.ToLower(strings.TrimSpace(field))

	// document-level
	if strings.HasPrefix(f, "sbom_") {
		if getDocField, ok := e.docGetters[f]; ok {
			return getDocField(e.Doc)
		}
		return nil
	}

	// component-level
	if getCompField, ok := e.compGetters[f]; ok {
		return getCompField(comp)
	}
	return nil
}
pkg/policy/extractor.go:299:1: receiver-naming: receiver name extract should be consistent with previous receiver name extractor for Extractor (revive)
func (extract *Extractor) HasField(comp sbom.GetComponent, field string) bool {
	vals := extract.RetrieveValues(comp, field)
	return len(vals) > 0
}
pkg/policy/policy.go:25:6: exported: exported type Params should have comment or be unexported (revive)
type Params struct {
     ^
pkg/policy/policy.go:40:6: exported: type name will be used as policy.PolicyFile by other packages, and that stutters; consider calling this File (revive)
type PolicyFile struct {
     ^
pkg/policy/result.go:17:1: exported: comment on exported type PolicyResult should be of the form "PolicyResult ..." (with optional leading article) (revive)
// Result represent the evaluation result of policay against SBOM
^
pkg/policy/result.go:18:6: exported: type name will be used as policy.PolicyResult by other packages, and that stutters; consider calling this Result (revive)
type PolicyResult struct {
     ^
pkg/policy/result.go:30:6: exported: exported type RuleResult should have comment or be unexported (revive)
type RuleResult struct {
     ^
pkg/policy/result.go:40:1: exported: exported function NewPolicyResult should have comment or be unexported (revive)
func NewPolicyResult(p Policy) *PolicyResult {
^
pkg/policy/rule.go:22:6: exported: exported type RULE_TYPE should have comment or be unexported (revive)
type RULE_TYPE string
     ^
pkg/policy/rule.go:25:2: exported: exported var REQUIRED should have comment or be unexported (revive)
	REQUIRED  RULE_TYPE = "required"
	^
pkg/purl/purl.go:15:1: package-comments: should have a package comment (revive)
package purl
^
pkg/purl/purl.go:21:6: exported: exported type PURL should have comment or be unexported (revive)
type PURL string
     ^
pkg/purl/purl.go:23:1: exported: exported function NewPURL should have comment or be unexported (revive)
func NewPURL(prl string) PURL {
^
pkg/purl/purl.go:27:1: exported: exported method PURL.Valid should have comment or be unexported (revive)
func (p PURL) Valid() bool {
^
pkg/reporter/basic.go:15:1: package-comments: should have a package comment (revive)
package reporter
^
pkg/reporter/report.go:25:6: exported: exported type Reporter should have comment or be unexported (revive)
type Reporter struct {
     ^
pkg/reporter/report.go:37:5: exported: exported var ReportFormats should have comment or be unexported (revive)
var ReportFormats = []string{"basic", "detailed", "json"}
    ^
pkg/reporter/report.go:39:6: exported: exported type Option should have comment or be unexported (revive)
type Option func(r *Reporter)
     ^
pkg/reporter/report.go:41:1: exported: exported function WithFormat should have comment or be unexported (revive)
func WithFormat(c string) Option {
^
pkg/reporter/report.go:47:1: exported: exported function WithColor should have comment or be unexported (revive)
func WithColor(c bool) Option {
^
pkg/reporter/report.go:53:1: exported: exported function NewReport should have comment or be unexported (revive)
func NewReport(ctx context.Context, doc []sbom.Document, scores []scorer.Scores, paths []string, opts ...Option) *Reporter {
^
pkg/reporter/report.go:67:1: exported: exported method Reporter.Report should have comment or be unexported (revive)
func (r *Reporter) Report() {
^
pkg/reporter/report.go:82:1: exported: exported method Reporter.ShareReport should have comment or be unexported (revive)
func (r *Reporter) ShareReport() (string, error) {
^
pkg/reporter/v2/basic.go:15:1: package-comments: should have a package comment (revive)
package v2
^
pkg/reporter/v2/reporter.go:10:7: exported: exported const EngineVersion should have comment or be unexported (revive)
const EngineVersion = "2"
      ^
pkg/reporter/v2/reporter.go:12:6: exported: exported type ReportFormat should have comment or be unexported (revive)
type ReportFormat string
     ^
pkg/reporter/v2/reporter.go:15:2: exported: exported var REPORT_BASIC should have comment or be unexported (revive)
	REPORT_BASIC    ReportFormat = "basic"
	^
pkg/reporter/v2/reporter.go:16:2: var-naming: don't use ALL_CAPS in Go names; use CamelCase (revive)
	REPORT_JSON     ReportFormat = "json"
	^
pkg/reporter/v2/reporter.go:17:2: var-naming: don't use ALL_CAPS in Go names; use CamelCase (revive)
	REPORT_DETAILED ReportFormat = "detailed"
	^
pkg/reporter/v2/reporter.go:20:6: exported: exported type Reporter should have comment or be unexported (revive)
type Reporter struct {
     ^
pkg/reporter/v2/reporter.go:26:1: exported: exported function NewReport should have comment or be unexported (revive)
func NewReport(ctx context.Context, results []api.Result, rFormat string) *Reporter {
^
pkg/reporter/v2/reporter.go:36:1: exported: exported method Reporter.Report should have comment or be unexported (revive)
func (r *Reporter) Report() {
^
pkg/sbom/author.go:15:1: package-comments: should have a package comment (revive)
package sbom
^
pkg/sbom/author.go:18:6: exported: exported type GetAuthor should have comment or be unexported (revive)
type GetAuthor interface {
     ^
pkg/sbom/author.go:25:6: exported: exported type Author should have comment or be unexported (revive)
type Author struct {
     ^
pkg/sbom/author.go:32:1: exported: exported method Author.GetName should have comment or be unexported (revive)
func (a Author) GetName() string {
^
pkg/sbom/author.go:36:1: exported: exported method Author.GetType should have comment or be unexported (revive)
func (a Author) GetType() string {
^
pkg/sbom/author.go:40:1: exported: exported method Author.GetEmail should have comment or be unexported (revive)
func (a Author) GetEmail() string {
^
pkg/sbom/author.go:44:1: exported: exported method Author.GetPhone should have comment or be unexported (revive)
func (a Author) GetPhone() string {
^
pkg/sbom/cdx.go:49:6: exported: exported type CdxDoc should have comment or be unexported (revive)
type CdxDoc struct {
     ^
pkg/sbom/cdx.go:110:1: exported: exported method CdxDoc.PrimaryComp should have comment or be unexported (revive)
func (c CdxDoc) PrimaryComp() GetPrimaryComp {
^
pkg/sbom/cdx.go:114:1: exported: exported method CdxDoc.Spec should have comment or be unexported (revive)
func (c CdxDoc) Spec() Spec {
^
pkg/sbom/cdx.go:118:1: exported: exported method CdxDoc.Components should have comment or be unexported (revive)
func (c CdxDoc) Components() []GetComponent {
^
pkg/sbom/cdx.go:122:1: exported: exported method CdxDoc.Authors should have comment or be unexported (revive)
func (c CdxDoc) Authors() []GetAuthor {
^
pkg/sbom/cdx.go:126:1: exported: exported method CdxDoc.Tools should have comment or be unexported (revive)
func (c CdxDoc) Tools() []GetTool {
^
pkg/sbom/cdx.go:130:1: exported: exported method CdxDoc.Relations should have comment or be unexported (revive)
func (c CdxDoc) Relations() []GetRelation {
^
pkg/sbom/cdx.go:134:1: exported: exported method CdxDoc.Logs should have comment or be unexported (revive)
func (c CdxDoc) Logs() []string {
^
pkg/sbom/cdx.go:138:1: exported: exported method CdxDoc.Lifecycles should have comment or be unexported (revive)
func (c CdxDoc) Lifecycles() []string {
^
pkg/sbom/cdx.go:142:1: exported: exported method CdxDoc.Supplier should have comment or be unexported (revive)
func (c CdxDoc) Supplier() GetSupplier {
^
pkg/sbom/cdx.go:146:1: exported: exported method CdxDoc.Manufacturer should have comment or be unexported (revive)
func (c CdxDoc) Manufacturer() GetManufacturer {
^
pkg/sbom/cdx.go:150:1: exported: exported method CdxDoc.GetRelationships should have comment or be unexported (revive)
func (c CdxDoc) GetRelationships(componentID string) []string {
^
pkg/sbom/cdx.go:154:1: exported: exported method CdxDoc.GetComposition should have comment or be unexported (revive)
func (c CdxDoc) GetComposition(componentID string) string {
^
pkg/sbom/cdx.go:158:1: exported: exported method CdxDoc.Vulnerabilities should have comment or be unexported (revive)
func (c CdxDoc) Vulnerabilities() []GetVulnerabilities {
^
pkg/sbom/cdx.go:162:1: exported: exported method CdxDoc.Signature should have comment or be unexported (revive)
func (c CdxDoc) Signature() GetSignature {
^
pkg/sbom/cdx.go:166:1: exported: exported method CdxDoc.SchemaValidation should have comment or be unexported (revive)
func (c CdxDoc) SchemaValidation() bool {
^
pkg/sbom/checksum.go:18:6: exported: exported type GetChecksum should have comment or be unexported (revive)
type GetChecksum interface {
     ^
pkg/sbom/checksum.go:23:6: exported: exported type Checksum should have comment or be unexported (revive)
type Checksum struct {
     ^
pkg/sbom/checksum.go:28:1: exported: exported method Checksum.GetAlgo should have comment or be unexported (revive)
func (c Checksum) GetAlgo() string {
^
pkg/sbom/checksum.go:32:1: exported: exported method Checksum.GetContent should have comment or be unexported (revive)
func (c Checksum) GetContent() string {
^
pkg/sbom/component.go:27:6: exported: exported type GetComponent should have comment or be unexported (revive)
type GetComponent interface {
     ^
pkg/sbom/component.go:63:6: exported: exported type Component should have comment or be unexported (revive)
type Component struct {
     ^
pkg/sbom/component.go:99:1: exported: exported function NewComponent should have comment or be unexported (revive)
func NewComponent() *Component {
^
pkg/sbom/component.go:103:1: exported: exported method Component.GetPrimaryCompInfo should have comment or be unexported (revive)
func (c Component) GetPrimaryCompInfo() GetPrimaryComp {
^
pkg/sbom/component.go:107:1: exported: exported method Component.GetName should have comment or be unexported (revive)
func (c Component) GetName() string {
^
pkg/sbom/component.go:111:1: exported: exported method Component.GetVersion should have comment or be unexported (revive)
func (c Component) GetVersion() string {
^
pkg/sbom/component.go:115:1: exported: exported method Component.GetPurls should have comment or be unexported (revive)
func (c Component) GetPurls() []purl.PURL {
^
pkg/sbom/component.go:119:1: exported: exported method Component.GetCpes should have comment or be unexported (revive)
func (c Component) GetCpes() []cpe.CPE {
^
pkg/sbom/component.go:123:1: exported: exported method Component.Swhids should have comment or be unexported (revive)
func (c Component) Swhids() []swhid.SWHID {
^
pkg/sbom/component.go:127:1: exported: exported method Component.Swids should have comment or be unexported (revive)
func (c Component) Swids() []swid.SWID {
^
pkg/sbom/component.go:131:1: exported: exported method Component.OmniborIDs should have comment or be unexported (revive)
func (c Component) OmniborIDs() []omniborid.OMNIBORID {
^
pkg/sbom/component.go:135:1: exported: exported method Component.GetLicenses should have comment or be unexported (revive)
func (c Component) GetLicenses() []licenses.License {
^
pkg/sbom/component.go:139:1: exported: exported method Component.DeclaredLicenses should have comment or be unexported (revive)
func (c Component) DeclaredLicenses() []licenses.License {
^
pkg/sbom/component.go:143:1: exported: exported method Component.ConcludedLicenses should have comment or be unexported (revive)
func (c Component) ConcludedLicenses() []licenses.License {
^
pkg/sbom/component.go:147:1: exported: exported method Component.GetChecksums should have comment or be unexported (revive)
func (c Component) GetChecksums() []GetChecksum {
^
pkg/sbom/component.go:151:1: exported: exported method Component.PrimaryPurpose should have comment or be unexported (revive)
func (c Component) PrimaryPurpose() string {
^
pkg/sbom/component.go:155:1: exported: exported method Component.RequiredFields should have comment or be unexported (revive)
func (c Component) RequiredFields() bool {
^
pkg/sbom/component.go:159:1: exported: exported method Component.GetID should have comment or be unexported (revive)
func (c Component) GetID() string {
^
pkg/sbom/component.go:163:1: exported: exported method Component.Manufacturer should have comment or be unexported (revive)
func (c Component) Manufacturer() GetManufacturer {
^
pkg/sbom/component.go:167:1: exported: exported method Component.Suppliers should have comment or be unexported (revive)
func (c Component) Suppliers() GetSupplier {
^
pkg/sbom/component.go:171:1: exported: exported method Component.Authors should have comment or be unexported (revive)
func (c Component) Authors() []GetAuthor {
^
pkg/sbom/component.go:175:1: exported: exported method Component.CountOfDependencies should have comment or be unexported (revive)
func (c Component) CountOfDependencies() int {
^
pkg/sbom/component.go:179:1: exported: exported method Component.Deps should have comment or be unexported (revive)
func (c Component) Deps() []string {
^
pkg/sbom/component.go:183:1: exported: exported method Component.GetSourceCodeURL should have comment or be unexported (revive)
func (c Component) GetSourceCodeURL() string {
^
pkg/sbom/component.go:187:1: exported: exported method Component.GetDownloadLocationURL should have comment or be unexported (revive)
func (c Component) GetDownloadLocationURL() string {
^
pkg/sbom/component.go:191:1: exported: exported method Component.SourceCodeHash should have comment or be unexported (revive)
func (c Component) SourceCodeHash() string {
^
pkg/sbom/component.go:195:1: exported: exported method Component.IsPrimaryComponent should have comment or be unexported (revive)
func (c Component) IsPrimaryComponent() bool {
^
pkg/sbom/component.go:199:1: exported: exported method Component.HasRelationShips should have comment or be unexported (revive)
func (c Component) HasRelationShips() bool {
^
pkg/sbom/component.go:203:1: exported: exported method Component.RelationShipState should have comment or be unexported (revive)
func (c Component) RelationShipState() string {
^
pkg/sbom/component.go:207:1: exported: exported method Component.GetSpdxID should have comment or be unexported (revive)
func (c Component) GetSpdxID() string {
^
pkg/sbom/component.go:211:1: exported: exported method Component.GetFileAnalyzed should have comment or be unexported (revive)
func (c Component) GetFileAnalyzed() bool {
^
pkg/sbom/component.go:215:1: exported: exported method Component.GetCopyRight should have comment or be unexported (revive)
func (c Component) GetCopyRight() string {
^
pkg/sbom/component.go:219:1: exported: exported method Component.GetPackageLicenseConcluded should have comment or be unexported (revive)
func (c Component) GetPackageLicenseConcluded() string {
^
pkg/sbom/component.go:223:1: exported: exported method Component.GetPackageLicenseDeclared should have comment or be unexported (revive)
func (c Component) GetPackageLicenseDeclared() string {
^
pkg/sbom/component.go:227:1: exported: exported method Component.ExternalReferences should have comment or be unexported (revive)
func (c Component) ExternalReferences() []GetExternalReference {
^
pkg/sbom/component.go:231:1: exported: exported method Component.GetComposition should have comment or be unexported (revive)
func (c Component) GetComposition(componentID string) string {
^
pkg/sbom/contact.go:19:6: exported: exported type GetContact should have comment or be unexported (revive)
type GetContact interface {
     ^
pkg/sbom/contact.go:25:6: exported: exported type Contact should have comment or be unexported (revive)
type Contact struct {
     ^
pkg/sbom/contact.go:31:1: exported: exported method Contact.GetName should have comment or be unexported (revive)
func (c Contact) GetName() string {
^
pkg/sbom/contact.go:35:1: exported: exported method Contact.GetEmail should have comment or be unexported (revive)
func (c Contact) GetEmail() string {
^
pkg/sbom/contact.go:39:1: exported: exported method Contact.GetPhone should have comment or be unexported (revive)
func (c Contact) GetPhone() string {
^
pkg/sbom/document.go:20:6: exported: exported type Document should have comment or be unexported (revive)
type Document interface {
     ^
pkg/sbom/externalReference.go:19:6: exported: exported type GetExternalReference should have comment or be unexported (revive)
type GetExternalReference interface {
     ^
pkg/sbom/externalReference.go:24:6: exported: exported type ExternalReference should have comment or be unexported (revive)
type ExternalReference struct {
     ^
pkg/sbom/externalReference.go:29:1: exported: exported method ExternalReference.GetRefType should have comment or be unexported (revive)
func (e ExternalReference) GetRefType() string {
^
pkg/sbom/externalReference.go:33:1: exported: exported method ExternalReference.GetRefLocator should have comment or be unexported (revive)
func (e ExternalReference) GetRefLocator() string {
^
pkg/sbom/manufacturer.go:19:6: exported: exported type GetManufacturer should have comment or be unexported (revive)
type GetManufacturer interface {
     ^
pkg/sbom/manufacturer.go:26:6: exported: exported type Manufacturer should have comment or be unexported (revive)
type Manufacturer struct {
     ^
pkg/sbom/manufacturer.go:33:1: exported: exported method Manufacturer.GetName should have comment or be unexported (revive)
func (m Manufacturer) GetName() string {
^
pkg/sbom/manufacturer.go:37:1: exported: exported method Manufacturer.GetURL should have comment or be unexported (revive)
func (m Manufacturer) GetURL() string {
^
pkg/sbom/manufacturer.go:41:1: exported: exported method Manufacturer.GetEmail should have comment or be unexported (revive)
func (m Manufacturer) GetEmail() string {
^
pkg/sbom/manufacturer.go:45:1: exported: exported method Manufacturer.GetContacts should have comment or be unexported (revive)
func (m Manufacturer) GetContacts() []Contact {
^
pkg/sbom/primarycomp.go:19:6: exported: exported type GetPrimaryComp should have comment or be unexported (revive)
type GetPrimaryComp interface {
     ^
pkg/sbom/primarycomp.go:29:6: exported: exported type PrimaryComp should have comment or be unexported (revive)
type PrimaryComp struct {
     ^
pkg/sbom/primarycomp.go:39:1: exported: exported method PrimaryComp.IsPresent should have comment or be unexported (revive)
func (pc PrimaryComp) IsPresent() bool {
^
pkg/sbom/primarycomp.go:43:1: exported: exported method PrimaryComp.GetID should have comment or be unexported (revive)
func (pc PrimaryComp) GetID() string {
^
pkg/sbom/primarycomp.go:47:1: exported: exported method PrimaryComp.GetName should have comment or be unexported (revive)
func (pc PrimaryComp) GetName() string {
^
pkg/sbom/primarycomp.go:51:1: exported: exported method PrimaryComp.GetVersion should have comment or be unexported (revive)
func (pc PrimaryComp) GetVersion() string {
^
pkg/sbom/primarycomp.go:55:1: exported: exported method PrimaryComp.GetTotalNoOfDependencies should have comment or be unexported (revive)
func (pc PrimaryComp) GetTotalNoOfDependencies() int {
^
pkg/sbom/primarycomp.go:59:1: exported: exported method PrimaryComp.HasDependencies should have comment or be unexported (revive)
func (pc PrimaryComp) HasDependencies() bool {
^
pkg/sbom/primarycomp.go:63:1: exported: exported method PrimaryComp.GetDependencies should have comment or be unexported (revive)
func (pc PrimaryComp) GetDependencies() []string {
^
pkg/sbom/relation.go:18:6: exported: exported type GetRelation should have comment or be unexported (revive)
type GetRelation interface {
     ^
pkg/sbom/relation.go:23:6: exported: exported type Relation should have comment or be unexported (revive)
type Relation struct {
     ^
pkg/sbom/relation.go:28:1: exported: exported method Relation.GetFrom should have comment or be unexported (revive)
func (r Relation) GetFrom() string {
^
pkg/sbom/relation.go:32:1: exported: exported method Relation.GetTo should have comment or be unexported (revive)
func (r Relation) GetTo() string {
^
pkg/sbom/sbom.go:31:6: exported: exported type SpecFormat should have comment or be unexported (revive)
type SpecFormat string
     ^
pkg/sbom/sbom.go:34:2: exported: exported const SBOMSpecSPDX should have comment (or a comment on this block) or be unexported (revive)
	SBOMSpecSPDX    SpecFormat = "spdx"
	^
pkg/sbom/sbom.go:40:2: exported: exported type FileFormat should have comment or be unexported (revive)
	FileFormat    string
	^
pkg/sbom/sbom.go:41:2: exported: exported type FormatVersion should have comment or be unexported (revive)
	FormatVersion string
	^
pkg/sbom/sbom.go:45:2: exported: exported const FileFormatJSON should have comment (or a comment on this block) or be unexported (revive)
	FileFormatJSON     FileFormat = "json"
	^
pkg/sbom/sbom.go:63:1: exported: exported function SupportedSBOMSpecs should have comment or be unexported (revive)
func SupportedSBOMSpecs() []string {
^
pkg/sbom/sbom.go:67:1: exported: exported function SupportedSBOMSpecVersions should have comment or be unexported (revive)
func SupportedSBOMSpecVersions(f string) []string {
^
pkg/sbom/sbom.go:78:1: exported: exported function SupportedSBOMFileFormats should have comment or be unexported (revive)
func SupportedSBOMFileFormats(f string) []string {
^
pkg/sbom/sbom.go:89:1: exported: exported function SupportedPrimaryPurpose should have comment or be unexported (revive)
func SupportedPrimaryPurpose(f string) []string {
^
pkg/sbom/sbom.go:168:1: exported: exported function NewSBOMDocument should have comment or be unexported (revive)
func NewSBOMDocument(ctx context.Context, f io.ReadSeeker, sig Signature) (Document, error) {
^
pkg/sbom/signature.go:19:6: exported: exported type GetSignature should have comment or be unexported (revive)
type GetSignature interface {
     ^
pkg/sbom/signature.go:25:6: exported: exported type Signature should have comment or be unexported (revive)
type Signature struct {
     ^
pkg/sbom/signature.go:31:1: exported: exported method Signature.GetSigValue should have comment or be unexported (revive)
func (s *Signature) GetSigValue() string {
^
pkg/sbom/signature.go:35:1: exported: exported method Signature.GetPublicKey should have comment or be unexported (revive)
func (s *Signature) GetPublicKey() string {
^
pkg/sbom/signature.go:39:1: exported: exported method Signature.GetBlob should have comment or be unexported (revive)
func (s *Signature) GetBlob() string {
^
pkg/sbom/spdx.go:45:6: exported: exported type SpdxDoc should have comment or be unexported (revive)
type SpdxDoc struct {
     ^
pkg/sbom/spdx.go:107:1: exported: exported method SpdxDoc.PrimaryComp should have comment or be unexported (revive)
func (s SpdxDoc) PrimaryComp() GetPrimaryComp {
^
pkg/sbom/spdx.go:111:1: exported: exported method SpdxDoc.Spec should have comment or be unexported (revive)
func (s SpdxDoc) Spec() Spec {
^
pkg/sbom/spdx.go:115:1: exported: exported method SpdxDoc.Components should have comment or be unexported (revive)
func (s SpdxDoc) Components() []GetComponent {
^
pkg/sbom/spdx.go:119:1: exported: exported method SpdxDoc.Authors should have comment or be unexported (revive)
func (s SpdxDoc) Authors() []GetAuthor {
^
pkg/sbom/spdx.go:123:1: exported: exported method SpdxDoc.Tools should have comment or be unexported (revive)
func (s SpdxDoc) Tools() []GetTool {
^
pkg/sbom/spdx.go:127:1: exported: exported method SpdxDoc.Relations should have comment or be unexported (revive)
func (s SpdxDoc) Relations() []GetRelation {
^
pkg/sbom/spdx.go:131:1: exported: exported method SpdxDoc.Logs should have comment or be unexported (revive)
func (s SpdxDoc) Logs() []string {
^
pkg/sbom/spdx.go:135:1: exported: exported method SpdxDoc.Lifecycles should have comment or be unexported (revive)
func (s SpdxDoc) Lifecycles() []string {
^
pkg/sbom/spdx.go:139:1: exported: exported method SpdxDoc.Manufacturer should have comment or be unexported (revive)
func (s SpdxDoc) Manufacturer() GetManufacturer {
^
pkg/sbom/spdx.go:143:1: exported: exported method SpdxDoc.Supplier should have comment or be unexported (revive)
func (s SpdxDoc) Supplier() GetSupplier {
^
pkg/sbom/spdx.go:147:1: exported: exported method SpdxDoc.GetRelationships should have comment or be unexported (revive)
func (s SpdxDoc) GetRelationships(componentID string) []string {
^
pkg/sbom/spdx.go:151:1: exported: comment on exported function CleanKey should be of the form "CleanKey ..." (revive)
// Helper function to clean up keys
^
pkg/sbom/spdx.go:156:1: exported: exported method SpdxDoc.GetComposition should have comment or be unexported (revive)
func (s SpdxDoc) GetComposition(componentID string) string {
^
pkg/sbom/spdx.go:160:1: exported: exported method SpdxDoc.Vulnerabilities should have comment or be unexported (revive)
func (s SpdxDoc) Vulnerabilities() []GetVulnerabilities {
^
pkg/sbom/spdx.go:164:1: exported: exported method SpdxDoc.Signature should have comment or be unexported (revive)
func (s SpdxDoc) Signature() GetSignature {
^
pkg/sbom/spdx.go:168:1: exported: exported method SpdxDoc.SchemaValidation should have comment or be unexported (revive)
func (s SpdxDoc) SchemaValidation() bool {
^
pkg/sbom/spec.go:23:6: exported: exported type Spec should have comment or be unexported (revive)
type Spec interface {
     ^
pkg/sbom/spec.go:40:6: exported: exported type Specs should have comment or be unexported (revive)
type Specs struct {
     ^
pkg/sbom/spec.go:56:1: exported: exported function NewSpec should have comment or be unexported (revive)
func NewSpec() *Specs {
^
pkg/sbom/spec.go:60:1: exported: exported method Specs.GetOrganization should have comment or be unexported (revive)
func (s Specs) GetOrganization() string {
^
pkg/sbom/spec.go:64:1: exported: exported method Specs.GetComment should have comment or be unexported (revive)
func (s Specs) GetComment() string {
^
pkg/sbom/spec.go:68:1: exported: exported method Specs.GetSpdxID should have comment or be unexported (revive)
func (s Specs) GetSpdxID() string {
^
pkg/sbom/spec.go:72:1: exported: exported method Specs.GetVersion should have comment or be unexported (revive)
func (s Specs) GetVersion() string {
^
pkg/sbom/spec.go:76:1: exported: exported method Specs.FileFormat should have comment or be unexported (revive)
func (s Specs) FileFormat() string {
^
pkg/sbom/spec.go:80:1: exported: exported method Specs.Parsable should have comment or be unexported (revive)
func (s Specs) Parsable() bool {
^
pkg/sbom/spec.go:84:1: exported: exported method Specs.GetName should have comment or be unexported (revive)
func (s Specs) GetName() string {
^
pkg/sbom/spec.go:88:1: exported: exported method Specs.GetSpecType should have comment or be unexported (revive)
func (s Specs) GetSpecType() string {
^
pkg/sbom/spec.go:92:1: exported: exported method Specs.RequiredFields should have comment or be unexported (revive)
func (s Specs) RequiredFields() bool {
^
pkg/sbom/spec.go:96:1: exported: exported method Specs.GetCreationTimestamp should have comment or be unexported (revive)
func (s Specs) GetCreationTimestamp() string {
^
pkg/sbom/spec.go:100:1: exported: exported method Specs.GetLicenses should have comment or be unexported (revive)
func (s Specs) GetLicenses() []licenses.License {
^
pkg/sbom/spec.go:104:1: exported: exported method Specs.GetNamespace should have comment or be unexported (revive)
func (s Specs) GetNamespace() string {
^
pkg/sbom/spec.go:108:1: exported: exported method Specs.GetURI should have comment or be unexported (revive)
func (s Specs) GetURI() string {
^
pkg/sbom/spec.go:112:1: exported: exported method Specs.GetExtDocRef should have comment or be unexported (revive)
func (s Specs) GetExtDocRef() []string {
^
pkg/sbom/supplier.go:19:6: exported: exported type GetSupplier should have comment or be unexported (revive)
type GetSupplier interface {
     ^
pkg/sbom/supplier.go:27:6: exported: exported type Supplier should have comment or be unexported (revive)
type Supplier struct {
     ^
pkg/sbom/supplier.go:34:1: exported: exported method Supplier.GetName should have comment or be unexported (revive)
func (s Supplier) GetName() string {
^
pkg/sbom/supplier.go:38:1: exported: exported method Supplier.GetEmail should have comment or be unexported (revive)
func (s Supplier) GetEmail() string {
^
pkg/sbom/supplier.go:42:1: exported: exported method Supplier.GetURL should have comment or be unexported (revive)
func (s Supplier) GetURL() string {
^
pkg/sbom/supplier.go:46:1: exported: exported method Supplier.GetContacts should have comment or be unexported (revive)
func (s Supplier) GetContacts() []Contact {
^
pkg/sbom/supplier.go:50:1: exported: exported method Supplier.IsPresent should have comment or be unexported (revive)
func (s Supplier) IsPresent() bool {
^
pkg/sbom/tool.go:19:6: exported: exported type GetTool should have comment or be unexported (revive)
type GetTool interface {
     ^
pkg/sbom/tool.go:23:6: exported: exported type Tool should have comment or be unexported (revive)
type Tool struct {
     ^
pkg/sbom/tool.go:28:1: exported: exported method Tool.GetName should have comment or be unexported (revive)
func (t Tool) GetName() string {
^
pkg/sbom/tool.go:32:1: exported: exported method Tool.GetVersion should have comment or be unexported (revive)
func (t Tool) GetVersion() string {
^
pkg/sbom/vulnerabilities.go:19:6: exported: exported type GetVulnerabilities should have comment or be unexported (revive)
type GetVulnerabilities interface {
     ^
pkg/sbom/vulnerabilities.go:23:6: exported: exported type Vulnerability should have comment or be unexported (revive)
type Vulnerability struct {
     ^
pkg/sbom/vulnerabilities.go:27:1: exported: exported method Vulnerability.GetID should have comment or be unexported (revive)
func (v Vulnerability) GetID() string {
^
pkg/scorer/bsi.go:15:1: package-comments: should have a package comment (revive)
package scorer
^
pkg/scorer/config.go:25:6: exported: exported type Config should have comment or be unexported (revive)
type Config struct {
     ^
pkg/scorer/config.go:35:6: exported: exported type Cat should have comment or be unexported (revive)
type Cat struct {
     ^
pkg/scorer/config.go:40:6: exported: exported type Features should have comment or be unexported (revive)
type Features struct {
     ^
pkg/scorer/config.go:98:1: exported: exported function DefaultConfig should have comment or be unexported (revive)
func DefaultConfig() string {
^
pkg/scorer/config.go:147:1: exported: exported function ReadConfigFile should have comment or be unexported (revive)
func ReadConfigFile(path string) ([]Filter, error) {
^
pkg/scorer/scorer.go:24:7: exported: exported const EngineVersion should have comment or be unexported (revive)
const EngineVersion = "7"
      ^
pkg/scorer/scorer.go:29:2: exported: exported const Feature should have comment (or a comment on this block) or be unexported (revive)
	Feature filterType = iota
	^
pkg/scorer/scorer.go:34:6: exported: exported type Filter should have comment or be unexported (revive)
type Filter struct {
     ^
pkg/scorer/scorer.go:40:6: exported: exported type Scorer should have comment or be unexported (revive)
type Scorer struct {
     ^
pkg/scorer/scorer.go:50:1: exported: exported function NewScorer should have comment or be unexported (revive)
func NewScorer(ctx context.Context, doc sbom.Document) *Scorer {
^
pkg/scorer/scorer.go:62:1: exported: comment on exported method Scorer.AddFilter should be of the form "AddFilter ..." (revive)
// enable filtering by feature, category, or mix of both
^
pkg/scorer/scorer.go:78:1: exported: exported method Scorer.Score should have comment or be unexported (revive)
func (s *Scorer) Score() Scores {
^
pkg/scorer/scorer.go:142:1: exported: exported method Scorer.AllScores should have comment or be unexported (revive)
func (s *Scorer) AllScores() Scores {
^
pkg/scorer/v2/api/result.go:15:1: package-comments: should have a package comment (revive)
package api
^
pkg/scorer/v2/api/result.go:113:1: exported: exported function NewProfFeatResult should have comment or be unexported (revive)
func NewProfFeatResult(pFeat catalog.ProfFeatSpec) ProfileFeatureResult {
^
pkg/scorer/v2/api/result.go:124:1: exported: exported function NewComprFeatResult should have comment or be unexported (revive)
func NewComprFeatResult(comprFeat catalog.ComprFeatSpec) FeatureResult {
^
pkg/scorer/v2/api/result.go:133:1: exported: exported function NewComprResult should have comment or be unexported (revive)
func NewComprResult() ComprehensiveResult {
^
pkg/scorer/v2/api/result.go:137:1: exported: exported function NewCategoryResultFromSpec should have comment or be unexported (revive)
func NewCategoryResultFromSpec(cat catalog.ComprCatSpec) CategoryResult {
^
pkg/scorer/v2/api/result.go:145:1: exported: exported function NewResult should have comment or be unexported (revive)
func NewResult(doc sbom.Document) *Result {
^
pkg/scorer/v2/api/result.go:152:1: exported: exported function NewSBOMMeta should have comment or be unexported (revive)
func NewSBOMMeta(doc sbom.Document) SBOMMeta {
^
pkg/scorer/v2/catalog/catalog.go:15:1: package-comments: should have a package comment (revive)
package catalog
^
pkg/scorer/v2/catalog/catalog.go:22:2: exported: comment on exported type ComprCatKey should be of the form "ComprCatKey ..." (with optional leading article) (revive)
	// comprehenssive cateogy and it's features keys
	^
pkg/scorer/v2/catalog/catalog.go:24:2: exported: exported type ComprFeatKey should have comment or be unexported (revive)
	ComprFeatKey string
	^
pkg/scorer/v2/catalog/catalog.go:26:2: exported: comment on exported type ProfileKey should be of the form "ProfileKey ..." (with optional leading article) (revive)
	// profiles and it's feature keys
	^
pkg/scorer/v2/catalog/catalog.go:28:2: exported: exported type ProfFeatKey should have comment or be unexported (revive)
	ProfFeatKey string
	^
pkg/scorer/v2/catalog/catalog.go:50:1: exported: exported method Catalog.HasFeature should have comment or be unexported (revive)
func (c *Catalog) HasFeature(k ComprFeatKey) bool {
^
pkg/scorer/v2/catalog/catalog.go:59:1: exported: exported method Catalog.HasCategory should have comment or be unexported (revive)
func (c *Catalog) HasCategory(k ComprCatKey) bool {
^
pkg/scorer/v2/catalog/catalog.go:68:1: exported: exported method Catalog.HasProfile should have comment or be unexported (revive)
func (c *Catalog) HasProfile(k ProfileKey) bool {
^
pkg/scorer/v2/catalog/catalog.go:77:1: exported: exported method Catalog.ResolveCategoryAlias should have comment or be unexported (revive)
func (c *Catalog) ResolveCategoryAlias(s string) (ComprCatKey, bool) {
^
pkg/scorer/v2/catalog/catalog.go:82:1: exported: exported method Catalog.ResolveFeatureAlias should have comment or be unexported (revive)
func (c *Catalog) ResolveFeatureAlias(s string) (ComprFeatKey, bool) {
^
pkg/scorer/v2/catalog/catalog.go:87:1: exported: exported method Catalog.ResolveProfileAlias should have comment or be unexported (revive)
func (c *Catalog) ResolveProfileAlias(s string) (ProfileKey, bool) {
^
pkg/scorer/v2/catalog/profiles.go:47:6: exported: exported type ProfComplianceState should have comment or be unexported (revive)
type ProfComplianceState string
     ^
pkg/scorer/v2/common/common.go:15:1: package-comments: should have a package comment (revive)
package common
^
pkg/scorer/v2/common/common.go:27:1: exported: comment on exported function IsSupplierEntity should be of the form "IsSupplierEntity ..." to match its exported status, not "isSupplierEntity ..." (revive)
// isSupplierEntity check whether supplier is a legal entity or not:
^
pkg/scorer/v2/common/common.go:37:1: exported: comment on exported function IsSBOMAuthorEntity should be of the form "IsSBOMAuthorEntity ..." to match its exported status, not "isSBOMAuthorEntity ..." (revive)
// isSBOMAuthorEntity check whether author is a legal entity or not:
^
pkg/scorer/v2/common/common.go:48:1: exported: comment on exported function HasComponentPrimaryPackageType should be of the form "HasComponentPrimaryPackageType ..." (revive)
// Checks if component has primary purpose or type
^
pkg/scorer/v2/common/common.go:56:1: exported: exported function HasComponentSourceCodeURL should have comment or be unexported (revive)
func HasComponentSourceCodeURL(sourceCodeURL string) bool {
^
pkg/scorer/v2/common/common.go:63:1: exported: exported function HasSBOMPrimaryComponent should have comment or be unexported (revive)
func HasSBOMPrimaryComponent(doc sbom.Document) bool {
^
pkg/scorer/v2/common/common.go:67:1: exported: exported function HasComponentDependencies should have comment or be unexported (revive)
func HasComponentDependencies(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:71:1: exported: exported function IsValidPURL should have comment or be unexported (revive)
func IsValidPURL(s string) bool {
^
pkg/scorer/v2/common/common.go:89:1: exported: exported function IsValidCPE should have comment or be unexported (revive)
func IsValidCPE(s string) bool {
^
pkg/scorer/v2/common/common.go:105:1: exported: exported function CompHasAnyPURLs should have comment or be unexported (revive)
func CompHasAnyPURLs(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:114:1: exported: exported function CompHasAnyCPEs should have comment or be unexported (revive)
func CompHasAnyCPEs(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:123:1: exported: comment on exported function ValidateLicenseText should be of the form "ValidateLicenseText ..." (revive)
// license with "NOASSERTION" or "NONE" are considered as
^
pkg/scorer/v2/common/common.go:137:1: exported: exported function ValidationCheckConcludedLicenses should have comment or be unexported (revive)
func ValidationCheckConcludedLicenses(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:146:1: exported: exported function AreLicensesValid should have comment or be unexported (revive)
func AreLicensesValid(licenses []licenses.License) bool {
^
pkg/scorer/v2/common/common.go:168:1: exported: exported function ComponentHasAnyConcluded should have comment or be unexported (revive)
func ComponentHasAnyConcluded(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:180:1: exported: exported function ComponentHasAnyDeclared should have comment or be unexported (revive)
func ComponentHasAnyDeclared(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:192:1: exported: exported function ComponentHasAnyDeprecated should have comment or be unexported (revive)
func ComponentHasAnyDeprecated(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:201:1: exported: exported function ComponentHasAnyRestrictive should have comment or be unexported (revive)
func ComponentHasAnyRestrictive(c sbom.GetComponent) bool {
^
pkg/scorer/v2/common/common.go:252:1: exported: comment on exported function IsWeakChecksum should be of the form "IsWeakChecksum ..." to match its exported status, not "isWeakChecksum ..." (revive)
// isWeakChecksum returns true for weak/broken hash algorithms.
^
pkg/scorer/v2/common/common.go:270:1: exported: comment on exported function IsStrongChecksum should be of the form "IsStrongChecksum ..." to match its exported status, not "isStrongChecksum ..." (revive)
// isStrongChecksum returns true for strong hash algorithms.
^
pkg/scorer/v2/comprehenssive/compr.go:15:1: package-comments: should have a package comment (revive)
package comprehenssive
^
pkg/scorer/v2/comprehenssive/compr.go:27:1: exported: exported function Evaluate should have comment or be unexported (revive)
func Evaluate(ctx context.Context, catal *catalog.Catalog, doc sbom.Document) api.ComprehensiveResult {
^
pkg/scorer/v2/config/config.go:15:1: package-comments: should have a package comment (revive)
package config
^
pkg/scorer/v2/config/config.go:21:6: exported: exported type Config should have comment or be unexported (revive)
type Config struct {
     ^
pkg/scorer/v2/extractors/completeness.go:15:1: package-comments: should have a package comment (revive)
package extractors
^
pkg/scorer/v2/extractors/completeness.go:25:1: exported: comment on exported function CompWithDependencies should be of the form "CompWithDependencies ..." (revive)
// comp_with_dependencies (component-level coverage)
^
pkg/scorer/v2/extractors/completeness.go:40:1: exported: comment on exported function CompWithCompleteness should be of the form "CompWithCompleteness ..." (revive)
// comp_with_declared_completeness: Completeness declaration present
^
pkg/scorer/v2/extractors/completeness.go:77:1: exported: comment on exported function SBOMWithPrimaryComponent should be of the form "SBOMWithPrimaryComponent ..." (revive)
// sbom_with_primary_comp: Single primary component defined
^
pkg/scorer/v2/extractors/completeness.go:96:1: exported: comment on exported function CompWithSourceCode should be of the form "CompWithSourceCode ..." (revive)
// comps_with_source_code: Valid VCS URL
^
pkg/scorer/v2/extractors/completeness.go:110:1: exported: comment on exported function CompWithSupplier should be of the form "CompWithSupplier ..." (revive)
// comp_with_supplier
^
pkg/scorer/v2/extractors/completeness.go:124:1: exported: comment on exported function CompWithPackagePurpose should be of the form "CompWithPackagePurpose ..." (revive)
// comp_with_primary_purpose
^
pkg/scorer/v2/extractors/compquality.go:23:1: exported: comment on exported function CompWithEOSOrEOL should be of the form "CompWithEOSOrEOL ..." (revive)
// Components no longer maintained or declared end-of-life
^
pkg/scorer/v2/extractors/compquality.go:24:23: unused-parameter: parameter 'doc' seems to be unused, consider removing or renaming it as _ (revive)
func CompWithEOSOrEOL(doc sbom.Document) catalog.ComprFeatScore {
                      ^
pkg/scorer/v2/extractors/compquality.go:28:1: exported: comment on exported function CompWithMalicious should be of the form "CompWithMalicious ..." (revive)
// Components tagged as malicious in threat databases
^
pkg/scorer/v2/extractors/compquality.go:29:24: unused-parameter: parameter 'doc' seems to be unused, consider removing or renaming it as _ (revive)
func CompWithMalicious(doc sbom.Document) catalog.ComprFeatScore {
                       ^
pkg/scorer/v2/extractors/compquality.go:33:1: exported: comment on exported function CompWithHighEPSS should be of the form "CompWithHighEPSS ..." (revive)
// Components with Exploit Prediction Scoring System > 0.8
^
pkg/scorer/v2/extractors/compquality.go:34:23: unused-parameter: parameter 'doc' seems to be unused, consider removing or renaming it as _ (revive)
func CompWithHighEPSS(doc sbom.Document) catalog.ComprFeatScore {
                      ^
pkg/scorer/v2/extractors/compquality.go:38:1: exported: comment on exported function CompWithVulnSeverityCritical should be of the form "CompWithVulnSeverityCritical ..." (revive)
// Components with vulnerabilities in CISA's Known Exploited Vulns
^
pkg/scorer/v2/extractors/compquality.go:39:35: unused-parameter: parameter 'doc' seems to be unused, consider removing or renaming it as _ (revive)
func CompWithVulnSeverityCritical(doc sbom.Document) catalog.ComprFeatScore {
                                  ^
pkg/scorer/v2/extractors/compquality.go:43:1: exported: exported function CompWithKev should have comment or be unexported (revive)
func CompWithKev(doc sbom.Document) catalog.ComprFeatScore {
^
pkg/scorer/v2/extractors/compquality.go:47:1: exported: exported function CompWithPurlValid should have comment or be unexported (revive)
func CompWithPurlValid(doc sbom.Document) catalog.ComprFeatScore {
^
pkg/scorer/v2/extractors/compquality.go:51:1: exported: exported function CompWithCpeValid should have comment or be unexported (revive)
func CompWithCpeValid(doc sbom.Document) catalog.ComprFeatScore{
^
pkg/scorer/v2/extractors/identification.go:26:1: exported: comment on exported function CompWithName should be of the form "CompWithName ..." (revive)
// CompWithName: percentage of components that have a non-empty name.
^
pkg/scorer/v2/extractors/identification.go:40:1: exported: comment on exported function CompWithVersion should be of the form "CompWithVersion ..." (revive)
// CompWithVersion: percentage of components that have a non-empty version.
^
pkg/scorer/v2/extractors/identification.go:54:1: exported: comment on exported function CompWithUniqLocalIDs should be of the form "CompWithUniqLocalIDs ..." (revive)
// CompWithUniqLocalIDs: percentage of components whose local ID is present and unique within the SBOM.
^
pkg/scorer/v2/extractors/provenance.go:28:1: exported: comment on exported function SBOMCreationTimestamp should be of the form "SBOMCreationTimestamp ..." (revive)
// SBOMCreationTime: document has a valid ISO-8601 timestamp (RFC3339/RFC3339Nano).
^
pkg/scorer/v2/extractors/provenance.go:58:1: exported: comment on exported function SBOMAuthors should be of the form "SBOMAuthors ..." (revive)
// SBOMAuthor represents an legal entity created an SBOM.
^
pkg/scorer/v2/extractors/provenance.go:76:1: exported: comment on exported function SBOMCreationTool should be of the form "SBOMCreationTool ..." (revive)
// SBOMCreationTool: tool name AND version(represents complete tool) present for at least one tool.
^
pkg/scorer/v2/extractors/provenance.go:137:1: exported: comment on exported function SBOMSupplier should be of the form "SBOMSupplier ..." (revive)
// SBOMSupplier: CDX-only (supplier/manufacturer in metadata).
^
pkg/scorer/v2/extractors/provenance.go:181:1: exported: comment on exported function SBOMNamespace should be of the form "SBOMNamespace ..." (revive)
// SBOMNamespace: required for both specs.
^
pkg/scorer/v2/extractors/provenance.go:226:1: exported: comment on exported function SBOMLifeCycle should be of the form "SBOMLifeCycle ..." (revive)
// SBOMLifeCycle: CDX-only (metadata.lifecycles/phase). N/A for SPDX.
^
pkg/scorer/v2/extractors/structural.go:55:1: exported: comment on exported function SBOMSpecVersion should be of the form "SBOMSpecVersion ..." (revive)
// SBOMSpecVersion: version supported for this spec?
^
pkg/scorer/v2/extractors/structural.go:92:1: exported: comment on exported function SBOMFileFormat should be of the form "SBOMFileFormat ..." (revive)
// SBOMFileFormat: file format supported for this spec?
^
pkg/scorer/v2/extractors/structural.go:123:1: exported: comment on exported function SBOMSchemaValid should be of the form "SBOMSchemaValid ..." (revive)
// SBOMSchemaValid: validate document against official schema for its spec/version.
^
pkg/scorer/v2/extractors/vulnerability.go:39:1: exported: comment on exported function CompWithCPE should be of the form "CompWithCPE ..." (revive)
// CompWithCPE: percentage of components that have at least one syntactically valid CPE 2.3.
^
pkg/scorer/v2/formulae/farmulas.go:15:1: package-comments: should have a package comment (revive)
package formulae
^
pkg/scorer/v2/formulae/farmulas.go:24:1: exported: comment on exported function ScoreCompNA should be of the form "ScoreCompNA ..." (revive)
// ScoreNA score NA for comprehenssive features related to components
^
pkg/scorer/v2/formulae/farmulas.go:33:1: exported: comment on exported function ScoreCompNAA should be of the form "ScoreCompNAA ..." (revive)
// ScoreNA score NA for comprehenssive features related to components
^
pkg/scorer/v2/formulae/farmulas.go:60:1: exported: comment on exported function ScoreProfFull should be of the form "ScoreProfFull ..." (revive)
// ScoreProfNA score for profile features related to components
^
pkg/scorer/v2/formulae/farmulas.go:69:1: exported: comment on exported function ScoreSBOMProfNA should be of the form "ScoreSBOMProfNA ..." (revive)
// ScoreProfNA score NA for profile features related to sbom
^
pkg/scorer/v2/formulae/farmulas.go:78:1: exported: comment on exported function ScoreSBOMProfFull should be of the form "ScoreSBOMProfFull ..." (revive)
// ScoreProfNA score full for profile features related to sbom
^
pkg/scorer/v2/formulae/farmulas.go:96:1: exported: comment on exported function ScoreSBOMProfUnknownNA should be of the form "ScoreSBOMProfUnknownNA ..." (revive)
// ScoreSBOMProfMissingNA score NA for profile features related to sbom
^
pkg/scorer/v2/formulae/farmulas.go:97:29: unused-parameter: parameter 'field' seems to be unused, consider removing or renaming it as _ (revive)
func ScoreSBOMProfUnknownNA(field string, ignore bool) catalog.ProfFeatScore {
                            ^
pkg/scorer/v2/formulae/farmulas.go:104:1: exported: exported function NoComponentsNAA should have comment or be unexported (revive)
func NoComponentsNAA() string          { return "N/A" }
^
pkg/scorer/v2/formulae/farmulas.go:105:1: exported: exported function NoComponentsNA should have comment or be unexported (revive)
func NoComponentsNA() string           { return "N/A (no components)" }
^
pkg/scorer/v2/formulae/farmulas.go:106:1: exported: exported function MissingField should have comment or be unexported (revive)
func MissingField(field string) string { return "add " + field }
^
pkg/scorer/v2/formulae/farmulas.go:107:1: exported: exported function PresentField should have comment or be unexported (revive)
func PresentField(field string) string { return "complete" }
^
pkg/scorer/v2/formulae/farmulas.go:108:1: exported: exported function NonSupportedSPDXField should have comment or be unexported (revive)
func NonSupportedSPDXField() string    { return "N/A (SPDX)" }
^
pkg/scorer/v2/formulae/farmulas.go:109:1: exported: exported function UnknownSpec should have comment or be unexported (revive)
func UnknownSpec() string              { return "N/A (unknown spec)" }
^
pkg/scorer/v2/formulae/farmulas.go:112:39: unused-parameter: parameter 'field' seems to be unused, consider removing or renaming it as _ (revive)
func CompDescription(have, total int, field string) string {
                                      ^
pkg/scorer/v2/formulae/farmulas.go:137:1: exported: comment on exported function BooleanScore should be of the form "BooleanScore ..." to match its exported status, not "booleanScore ..." (revive)
// booleanScore returns 10 if present, else 0.
^
pkg/scorer/v2/formulae/farmulas.go:145:1: exported: comment on exported function ToGrade should be of the form "ToGrade ..." (revive)
// Grade mapping (A: 910, B: 88.9, C: 77.9, D: 56.9, F: <5)
^
pkg/scorer/v2/formulae/farmulas.go:193:3: var-naming: don't use underscores in Go names; var score_i should be scoreI (revive)
		score_i := feature.Score
		^
pkg/scorer/v2/formulae/farmulas.go:194:3: var-naming: don't use underscores in Go names; var weight_i should be weightI (revive)
		weight_i := feature.Weight
		^
pkg/scorer/v2/formulae/farmulas.go:196:3: var-naming: don't use underscores in Go names; var normalizedWeight_i should be normalizedWeightI (revive)
		normalizedWeight_i := weight_i / totalFeatureWeight
		^
pkg/scorer/v2/formulae/farmulas.go:234:1: exported: exported function ComputeInterlynkProfScore should have comment or be unexported (revive)
func ComputeInterlynkProfScore(result api.ProfileResult) float64 {
^
pkg/scorer/v2/profiles/bsiv11.go:15:1: package-comments: should have a package comment (revive)
package profiles
^
pkg/scorer/v2/profiles/bsiv20.go:23:1: exported: comment on exported function BSISBOMWithBomLinks should be of the form "BSISBOMWithBomLinks ..." (revive)
// sbomWithBomLinksCheck
^
pkg/scorer/v2/profiles/bsiv20.go:37:1: exported: comment on exported function BSISBOMWithSignature should be of the form "BSISBOMWithSignature ..." (revive)
// BSISBOMWithSignature
^
pkg/scorer/v2/profiles/bsiv20.go:42:1: exported: comment on exported function BSICompWithAssociatedLicenses should be of the form "BSICompWithAssociatedLicenses ..." (revive)
// compWithAssociatedLicensesCheck: concluded for SPDX, effective for CDX components
^
pkg/scorer/v2/profiles/bsiv20.go:47:1: exported: comment on exported function CompWithConcludedLicensesCheck should be of the form "CompWithConcludedLicensesCheck ..." to match its exported status, not "compWithConcludedLicensesCheck ..." (revive)
// compWithConcludedLicensesCheck (SPDX)
^
pkg/scorer/v2/profiles/bsiv20.go:52:1: exported: comment on exported function CompWithDeclaredLicensesCheck should be of the form "CompWithDeclaredLicensesCheck ..." (revive)
// compWithDeclaredLicensesCheck
^
pkg/scorer/v2/profiles/common.go:152:1: exported: comment on exported function SBOMAuthors should be of the form "SBOMAuthors ..." (revive)
// SBOMAuthor represents an legal entity created an SBOM.
^
pkg/scorer/v2/profiles/common.go:168:1: exported: comment on exported function SBOMSupplier should be of the form "SBOMSupplier ..." (revive)
// SBOMSupplier: CDX-only (supplier/manufacturer in metadata).
^
pkg/scorer/v2/profiles/common.go:198:1: exported: comment on exported function SBOMCreationTimestamp should be of the form "SBOMCreationTimestamp ..." (revive)
// SBOMCreationTime check has a valid ISO-8601 timestamp (RFC3339/RFC3339Nano).
^
pkg/scorer/v2/profiles/common.go:235:1: exported: comment on exported function CompName should be of the form "CompName ..." (revive)
// CompName: percentage of components that have a non-empty name.
^
pkg/scorer/v2/profiles/common.go:250:1: exported: comment on exported function CompVersion should be of the form "CompVersion ..." (revive)
// CompVersion: percentage of components that have a non-empty version.
^
pkg/scorer/v2/profiles/common.go:264:1: exported: exported function CompSupplier should have comment or be unexported (revive)
func CompSupplier(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:329:1: exported: comment on exported function CompSHA256Plus should be of the form "CompSHA256Plus ..." (revive)
// CompWithSHA256Plus returns coverage of components that have SHA-256 or stronger.
^
pkg/scorer/v2/profiles/common.go:361:1: exported: comment on exported function CompCopyright should be of the form "CompCopyright ..." (revive)
// CompCopyright
^
pkg/scorer/v2/profiles/common.go:431:1: exported: exported function CompUniqID should have comment or be unexported (revive)
func CompUniqID(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:444:1: exported: exported function CompPURL should have comment or be unexported (revive)
func CompPURL(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:457:1: exported: exported function CompCPE should have comment or be unexported (revive)
func CompCPE(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:470:1: exported: exported function CompPurpose should have comment or be unexported (revive)
func CompPurpose(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:483:1: exported: exported function CompWithNODeprecatedLicenses should have comment or be unexported (revive)
func CompWithNODeprecatedLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:505:1: exported: exported function CompWithNORestrictiveLicenses should have comment or be unexported (revive)
func CompWithNORestrictiveLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:602:1: exported: exported function SBOMVulnerabilities should have comment or be unexported (revive)
func SBOMVulnerabilities(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:624:1: exported: exported function SBOMPrimaryComponent should have comment or be unexported (revive)
func SBOMPrimaryComponent(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:642:1: exported: exported function SBOMCompleteness should have comment or be unexported (revive)
func SBOMCompleteness(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:678:1: exported: exported function SBOMDataLicense should have comment or be unexported (revive)
func SBOMDataLicense(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/common.go:703:1: exported: exported function SBOMTool should have comment or be unexported (revive)
func SBOMTool(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:22:1: exported: comment on exported function InterCompWithName should be of the form "InterCompWithName ..." (revive)
// Identification
^
pkg/scorer/v2/profiles/interlynk.go:27:1: exported: exported function InterCompWithVersion should have comment or be unexported (revive)
func InterCompWithVersion(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:31:1: exported: exported function InterCompWithUniqueID should have comment or be unexported (revive)
func InterCompWithUniqueID(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:35:1: exported: comment on exported function InterSBOMTimestamp should be of the form "InterSBOMTimestamp ..." (revive)
// Provenance
^
pkg/scorer/v2/profiles/interlynk.go:40:1: exported: exported function InterSBOMAuthors should have comment or be unexported (revive)
func InterSBOMAuthors(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:44:1: exported: exported function InterSBOMTOol should have comment or be unexported (revive)
func InterSBOMTOol(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:48:1: exported: exported function InterSBOMSupplier should have comment or be unexported (revive)
func InterSBOMSupplier(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:52:1: exported: exported function InterSBOMNamespace should have comment or be unexported (revive)
func InterSBOMNamespace(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:56:1: exported: exported function InterSBOMLifecycle should have comment or be unexported (revive)
func InterSBOMLifecycle(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:60:1: exported: comment on exported function InterCompWithChecksum should be of the form "InterCompWithChecksum ..." (revive)
// Integrity
^
pkg/scorer/v2/profiles/interlynk.go:65:1: exported: exported function InterCompWithChecksum265 should have comment or be unexported (revive)
func InterCompWithChecksum265(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:69:1: exported: exported function InterSBOMSignature should have comment or be unexported (revive)
func InterSBOMSignature(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:73:1: exported: comment on exported function InterCompWithDependencies should be of the form "InterCompWithDependencies ..." (revive)
// Completeness
^
pkg/scorer/v2/profiles/interlynk.go:78:1: exported: exported function InterSBOMCompleteness should have comment or be unexported (revive)
func InterSBOMCompleteness(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:82:1: exported: exported function InterSBOMPrimaryComponent should have comment or be unexported (revive)
func InterSBOMPrimaryComponent(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:86:1: exported: exported function InterCompWithSourceCode should have comment or be unexported (revive)
func InterCompWithSourceCode(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:90:1: exported: exported function InterCompWithSupplier should have comment or be unexported (revive)
func InterCompWithSupplier(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:94:1: exported: exported function InterCompWithPurpose should have comment or be unexported (revive)
func InterCompWithPurpose(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:98:1: exported: comment on exported function InterCompWithLicenses should be of the form "InterCompWithLicenses ..." (revive)
// Licensing
^
pkg/scorer/v2/profiles/interlynk.go:103:1: exported: exported function InterCompWithValidLicenses should have comment or be unexported (revive)
func InterCompWithValidLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:107:1: exported: exported function InterCompWithDeclaredLicenses should have comment or be unexported (revive)
func InterCompWithDeclaredLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:111:1: exported: exported function InterCompWithConcludedLicenses should have comment or be unexported (revive)
func InterCompWithConcludedLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:115:1: exported: exported function InterSBOMDataLicenses should have comment or be unexported (revive)
func InterSBOMDataLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:119:1: exported: exported function InterCompWithNODeprecatedLicenses should have comment or be unexported (revive)
func InterCompWithNODeprecatedLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:123:1: exported: exported function InterCompWithNORestrictiveLicenses should have comment or be unexported (revive)
func InterCompWithNORestrictiveLicenses(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:127:1: exported: comment on exported function InterCompWithPURL should be of the form "InterCompWithPURL ..." (revive)
// Vulnerability
^
pkg/scorer/v2/profiles/interlynk.go:132:1: exported: exported function InterCompWithCPE should have comment or be unexported (revive)
func InterCompWithCPE(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:136:1: exported: comment on exported function InterSBOMSpec should be of the form "InterSBOMSpec ..." (revive)
// Structural
^
pkg/scorer/v2/profiles/interlynk.go:141:1: exported: exported function InterSBOMSpecVersion should have comment or be unexported (revive)
func InterSBOMSpecVersion(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:145:1: exported: exported function InterSBOMFileFormat should have comment or be unexported (revive)
func InterSBOMFileFormat(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/interlynk.go:149:1: exported: exported function InterSBOMSchema should have comment or be unexported (revive)
func InterSBOMSchema(doc sbom.Document) catalog.ProfFeatScore {
^
pkg/scorer/v2/profiles/ntia.go:24:1: exported: comment on exported function SBOMWithAutomationSpec should be of the form "SBOMWithAutomationSpec ..." (revive)
// Automation Support
^
pkg/scorer/v2/profiles/ntia.go:29:1: exported: comment on exported function SbomWithDepedencies should be of the form "SbomWithDepedencies ..." (revive)
// Dependency Relationships
^
pkg/scorer/v2/profiles/ntia.go:34:1: exported: comment on exported function SbomWithAuthors should be of the form "SbomWithAuthors ..." (revive)
// SBOM Author
^
pkg/scorer/v2/profiles/ntia.go:39:1: exported: comment on exported function SbomWithTimeStamp should be of the form "SbomWithTimeStamp ..." (revive)
// SBOM Timestamp
^
pkg/scorer/v2/profiles/ntia.go:44:1: exported: comment on exported function CompWithName should be of the form "CompWithName ..." (revive)
// Component Name
^
pkg/scorer/v2/profiles/ntia.go:49:1: exported: comment on exported function CompWithVersion should be of the form "CompWithVersion ..." (revive)
// Component Version
^
pkg/scorer/v2/profiles/ntia.go:54:1: exported: comment on exported function CompWithSupplier should be of the form "CompWithSupplier ..." (revive)
// Component Supplier
^
pkg/scorer/v2/profiles/ntia.go:59:1: exported: comment on exported function CompWithUniqID should be of the form "CompWithUniqID ..." (revive)
// Component Other Identifiers
^
pkg/scorer/v2/profiles/ntia.go:66:1: exported: comment on exported function NTIACompHash should be of the form "NTIACompHash ..." (revive)
// Component Hash (SHOULD)
^
pkg/scorer/v2/profiles/ntia.go:102:1: exported: comment on exported function NTIASBOMLifecycle should be of the form "NTIASBOMLifecycle ..." (revive)
// SBOM Lifecycle (SHOULD)
^
pkg/scorer/v2/profiles/ntia.go:117:1: exported: comment on exported function NTIACompRelationships should be of the form "NTIACompRelationships ..." (revive)
// Component Relationships (SHOULD)
^
pkg/scorer/v2/profiles/ntia.go:153:1: exported: comment on exported function NTIACompLicense should be of the form "NTIACompLicense ..." (revive)
// Component License (SHOULD)
^
pkg/scorer/v2/profiles/ntia_2025.go:23:1: exported: comment on exported function NTIA2025ToolName should be of the form "NTIA2025ToolName ..." (revive)
// NTIA2025 Tool Name - New requirement for NTIA 2025
^
pkg/scorer/v2/profiles/ntia_2025.go:45:1: exported: comment on exported function NTIA2025GenerationContext should be of the form "NTIA2025GenerationContext ..." (revive)
// NTIA2025 Generation Context - New requirement for NTIA 2025
^
pkg/scorer/v2/profiles/ntia_2025.go:72:1: exported: comment on exported function NTIA2025SoftwareProducer should be of the form "NTIA2025SoftwareProducer ..." (revive)
// NTIA2025 Software Producer - Required field for NTIA 2025
^
pkg/scorer/v2/profiles/ntia_2025.go:114:1: exported: comment on exported function NTIA2025CompHash should be of the form "NTIA2025CompHash ..." (revive)
// NTIA2025 Component Hash - Enhanced requirement for NTIA 2025
^
pkg/scorer/v2/profiles/ntia_2025.go:156:1: exported: comment on exported function NTIA2025CompLicense should be of the form "NTIA2025CompLicense ..." (revive)
// NTIA2025 License - Required for all components in NTIA 2025
^
pkg/scorer/v2/profiles/ntia_2025.go:218:1: exported: comment on exported function NTIA2025CompSoftwareIdentifiers should be of the form "NTIA2025CompSoftwareIdentifiers ..." (revive)
// NTIA2025 Software Identifiers - Enhanced requirement for NTIA 2025
^
pkg/scorer/v2/profiles/ntia_2025.go:229:2: var-naming: var componentsWithId should be componentsWithID (revive)
	componentsWithId := 0
	^
pkg/scorer/v2/profiles/ntia_2025.go:233:3: var-naming: var hasId should be hasID (revive)
		hasId := false
		^
pkg/scorer/v2/profiles/oct_v11.go:26:1: exported: comment on exported function OCTV11SBOMSpec should be of the form "OCTV11SBOMSpec ..." (revive)
// OCTV11SBOMSpec: SPDX Version / specVersion
^
pkg/scorer/v2/profiles/oct_v11.go:32:1: exported: comment on exported function OCTV11SBOMSpecVersion should be of the form "OCTV11SBOMSpecVersion ..." (revive)
// OCTV11SBOMSpecVersion: Spec Version
^
pkg/scorer/v2/profiles/oct_v11.go:38:1: exported: comment on exported function OCTV11SBOMDataLicense should be of the form "OCTV11SBOMDataLicense ..." (revive)
// OCTV11SBOMDataLicense: Data License / metadata.licenses
^
pkg/scorer/v2/profiles/oct_v11.go:61:1: exported: comment on exported function OCTV11SBOMIdentifier should be of the form "OCTV11SBOMIdentifier ..." (revive)
// OCTV11SBOMIdentifier: SPDX ID / serialNumber
^
pkg/scorer/v2/profiles/oct_v11.go:79:1: exported: comment on exported function OCTV11SBOMName should be of the form "OCTV11SBOMName ..." (revive)
// OCTV11SBOMName: Document Name (SPDX only)
^
pkg/scorer/v2/profiles/oct_v11.go:96:1: exported: comment on exported function OCTV11SBOMNamespace should be of the form "OCTV11SBOMNamespace ..." (revive)
// OCTV11SBOMNamespace: Document Namespace (SPDX only)
^
pkg/scorer/v2/profiles/oct_v11.go:113:1: exported: comment on exported function OCTV11SBOMCreator should be of the form "OCTV11SBOMCreator ..." (revive)
// OCTV11SBOMCreator: Creator (Organization & Tool)
^
pkg/scorer/v2/profiles/oct_v11.go:152:1: exported: comment on exported function OCTV11SBOMTimestamp should be of the form "OCTV11SBOMTimestamp ..." (revive)
// OCTV11SBOMTimestamp: Created timestamp
^
pkg/scorer/v2/profiles/oct_v11.go:158:1: exported: comment on exported function OCTV11SBOMCreatorComment should be of the form "OCTV11SBOMCreatorComment ..." (revive)
// OCTV11SBOMCreatorComment: Creator Comment / lifecycles
^
pkg/scorer/v2/profiles/oct_v11.go:179:1: exported: comment on exported function OCTV11CompName should be of the form "OCTV11CompName ..." (revive)
// OCTV11CompName: Package Name
^
pkg/scorer/v2/profiles/oct_v11.go:185:1: exported: comment on exported function OCTV11CompIdentifier should be of the form "OCTV11CompIdentifier ..." (revive)
// OCTV11CompIdentifier: Package SPDX ID / bom-ref
^
pkg/scorer/v2/profiles/oct_v11.go:210:1: exported: comment on exported function OCTV11CompVersion should be of the form "OCTV11CompVersion ..." (revive)
// OCTV11CompVersion: Package Version
^
pkg/scorer/v2/profiles/oct_v11.go:216:1: exported: comment on exported function OCTV11CompSupplier should be of the form "OCTV11CompSupplier ..." (revive)
// OCTV11CompSupplier: Package Supplier
^
pkg/scorer/v2/profiles/oct_v11.go:222:1: exported: comment on exported function OCTV11CompDownloadLocation should be of the form "OCTV11CompDownloadLocation ..." (revive)
// OCTV11CompDownloadLocation: Package Download Location / externalReferences
^
pkg/scorer/v2/profiles/oct_v11.go:228:1: exported: comment on exported function OCTV11CompLicenseConcluded should be of the form "OCTV11CompLicenseConcluded ..." (revive)
// OCTV11CompLicenseConcluded: Package License Concluded
^
pkg/scorer/v2/profiles/oct_v11.go:234:1: exported: comment on exported function OCTV11CompLicenseDeclared should be of the form "OCTV11CompLicenseDeclared ..." (revive)
// OCTV11CompLicenseDeclared: Package License Declared
^
pkg/scorer/v2/profiles/oct_v11.go:240:1: exported: comment on exported function OCTV11CompCopyright should be of the form "OCTV11CompCopyright ..." (revive)
// OCTV11CompCopyright: Package Copyright Text
^
pkg/scorer/v2/profiles/oct_v11.go:246:1: exported: comment on exported function OCTV11SBOMRelationships should be of the form "OCTV11SBOMRelationships ..." (revive)
// OCTV11SBOMRelationships: Relationships (DESCRIBES and CONTAINS)
^
pkg/scorer/v2/profiles/oct_v11.go:270:1: exported: comment on exported function OCTV11CompChecksum should be of the form "OCTV11CompChecksum ..." (revive)
// OCTV11CompChecksum: Package Checksum (SHOULD)
^
pkg/scorer/v2/profiles/oct_v11.go:284:1: exported: comment on exported function OCTV11CompPURL should be of the form "OCTV11CompPURL ..." (revive)
// OCTV11CompPURL: External Reference PURL (SHOULD)
^
pkg/scorer/v2/profiles_integration_test.go:536:37: unused-parameter: parameter 't' seems to be unused, consider removing or renaming it as _ (revive)
func Test_ProfileIntegrationSummary(t *testing.T) {
                                    ^
pkg/scorer/v2/registry/compr.go:15:1: package-comments: should have a package comment (revive)
package registry
^
pkg/scorer/v2/registry/compr.go:26:6: exported: exported type ComprConfig should have comment or be unexported (revive)
type ComprConfig struct {
     ^
pkg/scorer/v2/registry/compr.go:36:6: exported: exported type CatSpec should have comment or be unexported (revive)
type CatSpec struct {
     ^
pkg/scorer/v2/registry/compr.go:43:6: exported: exported type FeatSpec should have comment or be unexported (revive)
type FeatSpec struct {
     ^
pkg/scorer/v2/registry/compr.go:50:1: exported: exported function DefaultComprConfig should have comment or be unexported (revive)
func DefaultComprConfig() string {
^
pkg/scorer/v2/registry/profile.go:26:6: exported: exported type ProfileConfig should have comment or be unexported (revive)
type ProfileConfig struct {
     ^
pkg/scorer/v2/registry/profile.go:36:6: exported: exported type Prof should have comment or be unexported (revive)
type Prof struct {
     ^
pkg/scorer/v2/registry/profile.go:43:6: exported: exported type ProfFSpec should have comment or be unexported (revive)
type ProfFSpec struct {
     ^
pkg/scorer/v2/registry/profile.go:50:1: exported: exported function DefaultProfConfig should have comment or be unexported (revive)
func DefaultProfConfig() string {
^
pkg/scorer/v2/registry/registry.go:43:5: exported: exported var NTIAKeyToEvaluatingFunction should have comment or be unexported (revive)
var NTIAKeyToEvaluatingFunction = map[string]catalog.ProfFeatEval{
    ^
pkg/scorer/v2/registry/registry.go:53:5: exported: exported var NTIA2025KeyToEvaluatingFunction should have comment or be unexported (revive)
var NTIA2025KeyToEvaluatingFunction = map[string]catalog.ProfFeatEval{
    ^
pkg/scorer/v2/registry/registry.go:69:5: exported: exported var BSIV11KeyToEvaluatingFunction should have comment or be unexported (revive)
var BSIV11KeyToEvaluatingFunction = map[string]catalog.ProfFeatEval{
    ^
pkg/scorer/v2/registry/registry.go:89:5: exported: exported var BSIV20KeyToEvaluatingFunction should have comment or be unexported (revive)
var BSIV20KeyToEvaluatingFunction = map[string]catalog.ProfFeatEval{
    ^
pkg/scorer/v2/registry/registry.go:115:5: exported: exported var OCTV11KeyToEvaluatingFunction should have comment or be unexported (revive)
var OCTV11KeyToEvaluatingFunction = map[string]catalog.ProfFeatEval{
    ^
pkg/scorer/v2/registry/registry.go:265:1: exported: comment on exported function InitializeCatalog should be of the form "InitializeCatalog ..." (revive)
// Returns an error on serious IO / decode failures only.
^
pkg/scorer/v2/registry/registry.go:522:5: exported: exported var CatIdentificationSpec should have comment or be unexported (revive)
var CatIdentificationSpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:534:5: exported: exported var CatProvenanceSpec should have comment or be unexported (revive)
var CatProvenanceSpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:549:5: exported: exported var CatIntegritySpec should have comment or be unexported (revive)
var CatIntegritySpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:561:5: exported: exported var CatCompletenessSpec should have comment or be unexported (revive)
var CatCompletenessSpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:576:5: exported: exported var CatLicensingAndComplianceSpec should have comment or be unexported (revive)
var CatLicensingAndComplianceSpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:591:5: exported: exported var CatVulnerabilityAndTraceSpec should have comment or be unexported (revive)
var CatVulnerabilityAndTraceSpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:602:5: exported: exported var CatStructuralSpec should have comment or be unexported (revive)
var CatStructuralSpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:615:5: exported: exported var CatComponentQualityInfoSpec should have comment or be unexported (revive)
var CatComponentQualityInfoSpec = catalog.ComprCatSpec{
    ^
pkg/scorer/v2/registry/registry.go:825:5: exported: exported var Profile should have comment or be unexported (revive)
var Profile = []catalog.ProfSpec{
    ^
pkg/scorer/v2/score/resolver.go:15:1: package-comments: should have a package comment (revive)
package score
^
pkg/scorer/v2/score/resolver.go:30:1: exported: exported function ProcessURLPath should have comment or be unexported (revive)
func ProcessURLPath(ctx context.Context, cfg config.Config, url string) (*os.File, error) {
^
pkg/scorer/v2/score/resolver.go:109:1: exported: comment on exported function CategoryNames should be of the form "CategoryNames ..." (revive)
// helper for logging
^
pkg/scorer/v2/score/score.go:36:6: exported: func name will be used as score.ScoreSBOM by other packages, and that stutters; consider calling this SBOM (revive)
func ScoreSBOM(ctx context.Context, cfg config.Config, paths []string) ([]api.Result, error) {
     ^
pkg/scorer/v2/score/score.go:134:66: unused-parameter: parameter 'cfg' seems to be unused, consider removing or renaming it as _ (revive)
func SBOMEvaluation(ctx context.Context, catal *catalog.Catalog, cfg config.Config, doc sbom.Document) (api.Result, error) {
                                                                 ^
pkg/share/share.go:15:1: package-comments: should have a package comment (revive)
package share
^
pkg/share/share.go:31:1: exported: exported function Share should have comment or be unexported (revive)
func Share(ctx context.Context, doc sbom.Document, scores scorer.Scores, sbomFileName string) (string, error) {
^
pkg/swhid/swhid.go:15:1: package-comments: should have a package comment (revive)
package swhid
^
pkg/swhid/swhid.go:19:6: exported: exported type SWHID should have comment or be unexported (revive)
type SWHID string
     ^
pkg/swhid/swhid.go:23:1: exported: exported method SWHID.Valid should have comment or be unexported (revive)
func (swhid SWHID) Valid() bool {
^
pkg/swhid/swhid.go:27:1: exported: exported function NewSWHID should have comment or be unexported (revive)
func NewSWHID(swhid string) SWHID {
^
pkg/swid/swid.go:15:1: package-comments: should have a package comment (revive)
package swid
^
pkg/swid/swid.go:17:6: exported: exported type SWID should have comment or be unexported (revive)
type SWID interface {
     ^
pkg/swid/swid.go:46:1: exported: exported function NewSWID should have comment or be unexported (revive)
func NewSWID(tagID, name string) SWID {
^
pkg/utils/handler.go:15:1: package-comments: should have a package comment (revive)
package utils
^
pkg/utils/handler.go:27:1: exported: exported function IsDir should have comment or be unexported (revive)
func IsDir(path string) bool {
^
pkg/utils/handler.go:37:1: exported: comment on exported type Set should be of the form "Set ..." (with optional leading article) (revive)
// Set[T] is a generic "set" of values of type T.
^
pkg/utils/handler.go:52:1: exported: exported function IsURL should have comment or be unexported (revive)
func IsURL(in string) bool {
^
pkg/utils/handler.go:61:1: exported: exported function RemoveEmptyStrings should have comment or be unexported (revive)
func RemoveEmptyStrings(input []string) []string {
^
pkg/utils/handler.go:71:1: exported: exported function IsGit should have comment or be unexported (revive)
func IsGit(in string) bool {
^
pkg/utils/handler.go:75:1: exported: exported function HandleURL should have comment or be unexported (revive)
func HandleURL(path string) (string, string, error) {
^
pkg/utils/handler.go:103:1: exported: exported function DownloadSBOMFromURL should have comment or be unexported (revive)
func DownloadSBOMFromURL(url string) ([]byte, error) {
^
pkg/compliance/compliance.go:71:2: QF1002: could use tagged switch on reportType (staticcheck)
	switch {
	^
pkg/compliance/ntia.go:370:2: QF1003: could use tagged switch on spec (staticcheck)
	if spec == "spdx" {
	^
pkg/engine/share.go:46:11: ST1005: error strings should not be capitalized (staticcheck)
			return fmt.Errorf("Sharing doesn't support directories. Please provide a file path %s, it's not a file", ep.Path[0])
			       ^
pkg/list/compeval.go:379:2: S1008: should use 'return n == "SHA256"' instead of 'if n == "SHA256" { return true }; return false' (staticcheck)
	if n == "SHA256" {
	^
pkg/scorer/bsi.go:388:2: QF1003: could use tagged switch on spec (staticcheck)
	if spec == "spdx" {
	^
pkg/scorer/semantic.go:33:2: QF1007: could merge conditional assignment into variable declaration (staticcheck)
	pkgsOK := false
	^
pkg/scorer/v2/common/common.go:50:2: S1008: should use 'return strings.TrimSpace(compType) != ""' instead of 'if strings.TrimSpace(compType) != "" { return true }; return false' (staticcheck)
	if strings.TrimSpace(compType) != "" {
	^
pkg/scorer/v2/common/common.go:57:2: S1008: should use 'return strings.TrimSpace(sourceCodeURL) != ""' instead of 'if strings.TrimSpace(sourceCodeURL) != "" { return true }; return false' (staticcheck)
	if strings.TrimSpace(sourceCodeURL) != "" {
	^
pkg/scorer/v2/extractors/provenance_test.go:88:2: S1021: should merge variable declaration with assignment on next line (staticcheck)
	var supplier sbom.GetSupplier
	^
pkg/scorer/v2/profiles/bsiv20.go:27:3: SA4017: ScoreSBOMProfNA doesn't have side effects and its return value is ignored (staticcheck)
		formulae.ScoreSBOMProfNA("no bom links found", true)
		^
pkg/scorer/v2/profiles/ntia_2025.go:28:27: S1009: should omit nil check; len() for nil slices is defined as zero (staticcheck)
	if tools := doc.Tools(); tools != nil && len(tools) > 0 {
	                         ^
pkg/scorer/v2/registry/registry.go:386:19: ST1005: error strings should not be capitalized (staticcheck)
	return nil, nil, fmt.Errorf("Unknown config file, neither categories not profiles based")
	                 ^
pkg/scorer/v2/api/result.go:116:19: unnecessary conversion (unconvert)
		Key:      string(pFeat.Key),
		                ^
pkg/scorer/v2/api/result.go:127:17: unnecessary conversion (unconvert)
		Key:    string(comprFeat.Key),
		              ^
pkg/compliance/oct.go:145:32: breakLongString - maxLength always receives 50 (unparam)
func breakLongString(s string, maxLength int) []string {
                               ^
pkg/list/list.go:68:73: expandPathsToFiles - result 1 (error) is always nil (unparam)
func expandPathsToFiles(ctx context.Context, paths []string) ([]string, error) {
                                                                        ^
pkg/list/list.go:295:73: generateReport - result 0 (error) is always nil (unparam)
func generateReport(ctx context.Context, results []*Result, ep *Params) error {
                                                                        ^
pkg/scorer/score.go:60:27: (*score).setIgnore - i always receives true (unparam)
func (s *score) setIgnore(i bool) {
                          ^
pkg/scorer/v2/extractors/licensing_test.go:111:57: makeCDX14DocForLicensing - bomLicense always receives "CC0-1.0" (unparam)
func makeCDX14DocForLicensing(comps []licCdx14MiniComp, bomLicense string) sbom.Document {
                                                        ^
pkg/scorer/v2/extractors/structural_test.go:34:41: cdxSpecForStructural - spec always receives "cyclonedx" (unparam)
func cdxSpecForStructural(ver, fileFmt, spec string) *sbom.Specs {
                                        ^
pkg/scorer/v2/extractors/completeness_test.go:46:6: type cdxDocOpts2 is unused (unused)
type cdxDocOpts2 struct {
     ^
pkg/scorer/v2/extractors/integrity_test.go:199:6: func docValidBundle is unused (unused)
func docValidBundle() sbom.Document {
     ^
pkg/scorer/v2/profiles/bsiv11.go:23:2: var validBsiSpdxVersions is unused (unused)
	validBsiSpdxVersions = []string{"SPDX-2.3"}
	^
pkg/scorer/v2/profiles/bsiv11.go:24:2: var validBsiCdxVersions is unused (unused)
	validBsiCdxVersions  = []string{"1.4", "1.5", "1.6"}
	^
pkg/scorer/v2/profiles/common_test.go:258:6: func cdxDocForAuthor is unused (unused)
func cdxDocForAuthor(authors []author) sbom.CdxDoc {
     ^
pkg/scorer/v2/registry/registry.go:227:5: var categoryAlias is unused (unused)
var categoryAlias = map[string]catalog.ComprCatKey{
    ^
pkg/scorer/v2/registry/registry.go:243:5: var profileAliases is unused (unused)
var profileAliases = map[string]catalog.ProfileKey{
    ^
pkg/compliance/common/common.go:290:3: unnecessary trailing newline (whitespace)
		} else if doc.Spec().GetSpecType() == "cyclonedx" {
		^
pkg/compliance/common/common.go:305:3: unnecessary trailing newline (whitespace)
		} else if doc.Spec().GetSpecType() == "cyclonedx" {
		^
pkg/compliance/common/common.go:431:44: unnecessary leading newline (whitespace)
		if len(currentLine)+len(word)+1 > width {
		                                         ^
pkg/compliance/compliance.go:94:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/compliance/fsct/fsct.go:343:105: unnecessary leading newline (whitespace)
		if common.IsComponentPartOfPrimaryDependency(doc.PrimaryComp().GetDependencies(), component.GetID()) {
		                                                                                                      ^
pkg/compliance/fsct/fsct.go:349:44: unnecessary leading newline (whitespace)
			if len(getDependenciesOfComponent) > 0 {
			                                        ^
pkg/compliance/fsct/fsct.go:359:10: unnecessary leading newline (whitespace)
	switch {
	        ^
pkg/compliance/fsct/fsct.go:433:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/compliance/fsct/fsct_report.go:214:21: unnecessary leading newline (whitespace)
		if coloredOutput {
		                  ^
pkg/compliance/ntia.go:321:27: unnecessary leading newline (whitespace)
		if dependencies == nil {
		                        ^
pkg/compliance/ntia.go:328:3: unnecessary trailing newline (whitespace)
		}
		^
pkg/compliance/ntia.go:363:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/list/doceval.go:95:3: unnecessary trailing newline (whitespace)
		}
		^
pkg/list/doceval.go:218:46: unnecessary leading newline (whitespace)
	} else if spec == string(sbom.SBOMSpecCDX) {
	                                            ^
pkg/list/list.go:174:10: unnecessary leading newline (whitespace)
	switch {
	        ^
pkg/list/list.go:321:18: unnecessary leading newline (whitespace)
	switch feature {
	                ^
pkg/list/report.go:113:50: unnecessary leading newline (whitespace)
		if strings.HasPrefix(result.Feature, "comp_") {
		                                               ^
pkg/list/report.go:144:3: unnecessary trailing newline (whitespace)
		} else {
		^
pkg/policy/evaluator.go:80:4: unnecessary trailing newline (whitespace)
			} else {
			^
pkg/policy/evaluator.go:111:3: unnecessary trailing newline (whitespace)
		}
		^
pkg/policy/extractor.go:216:3: unnecessary trailing newline (whitespace)
		}
		^
pkg/policy/policy.go:90:32: unnecessary leading newline (whitespace)
	for _, rf := range ruleFlags {
	                              ^
pkg/reporter/v2/detailed.go:73:3: unnecessary trailing newline (whitespace)
		} else if r.Comprehensive != nil {
		^
pkg/sbom/spdx.go:414:4: unnecessary trailing newline (whitespace)
			} else {
			^
pkg/scorer/v2/formulae/farmulas.go:217:40: unnecessary leading newline (whitespace)
	for _, catResult := range catResults {
	                                      ^
pkg/scorer/v2/profiles/common.go:192:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/scorer/v2/profiles/profile.go:95:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/scorer/v2/registry/compr.go:64:39: unnecessary leading newline (whitespace)
		for _, pFeat := range cat.Features {
		                                    ^
pkg/scorer/v2/registry/compr.go:98:36: unnecessary leading newline (whitespace)
	for _, c := range cfg.Categories {
	                                  ^
pkg/scorer/v2/registry/compr.go:123:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/scorer/v2/registry/profile.go:141:32: unnecessary leading newline (whitespace)
	for _, f := range p.Features {
	                              ^
pkg/scorer/v2/registry/profile.go:152:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/scorer/v2/registry/registry.go:478:19: unnecessary leading newline (whitespace)
		switch profile {
		                ^
pkg/scorer/v2/registry/registry.go:513:2: unnecessary trailing newline (whitespace)
	}
	^
pkg/scorer/v2/score/score.go:142:2: unnecessary trailing newline (whitespace)
	} else if catal.Profiles != nil {
	^
877 issues:
* dupl: 30
* errcheck: 24
* gocognit: 14
* goconst: 67
* gocritic: 56
* gosec: 24
* govet: 1
* misspell: 4
* nilerr: 1
* nolintlint: 10
* prealloc: 35
* revive: 549
* staticcheck: 12
* unconvert: 2
* unparam: 6
* unused: 7
* whitespace: 35
make: *** [lint] Error 1
